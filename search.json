[{"title":"《中国合伙人》台词","url":"/posts/ae7bbd5b/","content":"\n“梦想是什么，梦想就是一种让你感到坚持就是幸福的东西”\n\n\n“我们在这谈了太多的思潮，主义，方法，为什么？因为我们都想找到一个现成的答案，我们都希望有人能够告诉我们应该怎样去生活，其实呢，没有人能告诉我们怎样去生活，因为生活是自己的，我们自己提出的问题应该自己去回答”——孟晓骏语\n\n其实每个人都有自己的人生路要走，无关乎对错，无论最后你活成了什么样，多年后当你能够平淡的和子孙后代说起来时，你的人生，依旧称得上传奇。\n\n“事实证明，一个人迫于无奈下的选择，往往是对的”\n\n所谓的迫于无奈的选择其实早已存在心里，只不过是有其他的选择影响你没有踏出这一步，让你在当时的环境下权衡利弊放弃了而已，而此刻的迫于无奈只是让你认识到，你已经什么都没有没有利弊让你去权衡，也没有退路，必须全力以赴，于是自然而然的选择了曾经抛弃的那个选项。\n\n“实践才是检验真理的唯一标准”——王洋语\n“所谓的美国梦，就是在梦想面前人人机会均等，全世界只有美国能做到这一点”——孟晓骏语\n\n当老师在课堂上讲美国的种族歧视问题时，孟晓骏反驳说老师是从书上看来的美国，此时的他们脑海中充满了对未来的畅想和对美国的向往，根本不能容忍有人说灯塔国的半点瑕疵，这和如今我们的绝大多数学生公知多么相似，历史总是在不断地重演，老师则回答他们“too young ,too naive”而他们也在未来用卑微实践证明现实和理想的差距\n\n“成功者总是不约而同的配合时代的需要”（被学校开除时——王洋语）\n“最大的骗子其实就是我们自己，因为我们总是想改变别人而不愿改变自己”——王洋语\n“我们改变不了世界，是世界改变了我们”——王洋语\n\n回想起刚入学时，大家意气风发，挥斥方遒，孟晓骏曾问哪一个词可以代表我们这代人，最后得出结论，是改变，改变自己，改变身边每一个人，改变世界，\n\n“你还年轻，你可以走的更远”——（孟晓骏餐厅洗盘子收小费）\n\n你还年轻，你可以成为任何你想成为的人，去做任何你想去做的事，现状已经很糟糕了，难道还会更糟糕吗，中国有个成语叫否极泰来，人会变事也会变，或许后天就是晴天。\n\n\n“掉在水里你不会淹死，呆在水里你才会淹死”\n\n学如逆水行舟，不进则退，什么都不做就什么都没有\n\n“我不走了，我留下来，成冬青，我以后跟你混”\n\n对应孟晓骏出国时说的那句话，我不回来了，只有经历过真实的美国，只有让他这样从小就自信心慢慢想要改变世界的人经历失败才能说出这种话，同时，也只有他自己知道说出这句话有多无奈和痛苦，这一刻，他才认清现实，才切身体会到了王洋在ktv说的那句话的含义，“我们改变不了世界，是世界改变了我们”\n\n“你有什么成功的公式吗？”“有吗？至少我不知道”\n\n每个人的成功都是偶然和必然的结合，那么每个人的成功当然也是不可复制的，你的经验在另一个人身上不一定百分之百适用，就像我们购买商品是外包装上总会标上一句，图案仅供参考，我们了解他人经验的目的只有一个，得出自己的成功公式，同样，孟晓骏回国后将当时美国的一些先进的思想，模式拿来给成冬青去看，成冬青也是先质疑，然后尝试，最后将这些本土化\n\n“当你意识到失败只是弯路，你就已经走在了成功的直道上”\n\n成功本就是一次一次的失败，一次一次的复盘最后的奖励，当你认识到意识到问题所在是，你也就踏出了收获成功的第一步\n\n“美国人炸了大使馆，你们就来砸英语学校，外星人炸了地球，你们要去砸航天部吗”\n\n这句话出在南斯拉夫大使馆被炸事件之后，当时激起了国人的爱国主义思潮，但同时也让我们看到了群众的盲目和反智。\n\n“你们和三十年前有什么区别，就知道窝里横，中国人打中国人，懦夫”\n\n当人们的情绪无法得到正常的宣泄，往往会将目标转向和它相关的实物，这时的人们是没有理智可言的，他们急于证明自己的勇气正义，阻碍他们的一切都是他们的敌人\n\n“做买卖的，低头弯腰下跪是基本功夫，小姐心态寡妇待遇，复联追求”\n\n\n“重要的不是成功，而是你不能没有尊严——苏梅语”\n\n看看孟晓骏的经历，看看新梦想的经历，对，人不能没有尊严，所有的关于成功所做的一切，都只是为了让你活得更有尊严。\n\n“如果额头终将刻上皱纹，你只能做到，不让皱纹刻在心上”\n\n或许这句话是对所谓的赤子之心 不忘初心最白话的解释了\n\n“成冬青压根就没想去改变世界，但它能做到，不被世界改变，永远的土鳖下去”\n\n这是在前文ktv包间里对王洋那一番话的回答，成冬青从来都没有什么雄心壮志，当他两次高考失利的时候，能有第三次机会，能进入大学校门就已经是对他最大的奖赏，他永远关注当下，当所有人都在畅想未来的时候，需要有人告诉世界如何践踏实地。\n孟晓骏计划了四年的上市计划，包括从加入新梦想后提的几十个商业计划，一直到差点和成冬青决裂，其实只是想挽回自己的尊严，想证明自己的价值，所以他在美国的经历回来后没有向王洋和成冬青说起，一次都没有，成冬青送给孟晓骏300平大房子的时候王洋说他不知道孟晓骏要什么，对，没有人知道一个从小接受良好的教育，从小自信满满要改变世界的人遭遇了重大失败后的内心世界是怎样的，当孟晓骏第三次到美国，并且是他们三人因为教材侵权问题一起到美国的时候，孟晓骏带他们来到自己曾经工作过的餐厅，讲述了自己前两次来美国的经历，这两人才知道他受到了怎样的打击，从一个一无所有心怀壮志的学生，到身价不菲事业有成的成功人士，他的所有身份都没有得到他想要的尊重，在第二次来美国将要离开的时候，他在时代广场看到新浪在纳斯达克上市的巨大版幅消息，或许此时他心里想，原来是这样，原来上市就能被这群美国佬正视，这唤回了他曾经的傲气与自信，他必须要获得应有的尊重。\n最终，成冬青的一番演讲让美国人认识到无数平凡的中国学生的真实状况，并且，为新梦想和孟晓骏，赢得了尊重。\n这是一个改变世界和被世界改变的故事，所以，锋芒外漏的孟晓骏活成了成冬青，永远土鳖的成冬青，活成了孟晓骏，就连罗曼蒂克的诗人王洋也不得不说一句真正的感情是安安静静就会来的一点都不折腾。\n最后，愿我们的心上永远都不会出现皱纹，永远的土鳖下去。\n","categories":["随笔"],"tags":["电影台词"]},{"title":"《你是我兄弟》台词摘录","url":"/posts/fc63e88/","content":"第六集\n“啥叫生意？生意就是让人生变得不可思议”\n“你别以为商人身上就充满铜臭，你仔细想想，钱就是钱，钱不臭啊，跟钱有啥关系，只要人心不臭，钱就不臭”\n第七集\n“卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭，看吧，在那镀金的天空中，飘满了死者弯曲的倒影”\n“冰川纪过去了，为什么到处都是冰凌，好望角发现了，为什么死海里千帆相竞，我来到这个世界上，只带着纸 绳索 和身影”\n“我不想第二次被打败，所以，我就不打 – 一枝花”\n“你现在用百分之百的努力辛勤耕耘，但是你只用百分之一的心情期待收获，免得你失恋了活不下去”\n“让你不断回忆的，一定是你没有得到的，正因为人们要不断地回忆，所以现在要尽最大可能地把它美好了，别等到你该回忆的时候你突然发现自己没什么可以回忆的，那人生就惨点喽”\n","categories":["随笔"],"tags":["电影台词"]},{"title":"OCLint静态代码校验初探","url":"/posts/7dc3b748/","content":"OCLint静态代码校验初探\n“OCLint是一个能够让我们的OC，C，C++代码变得更加优雅的检测分析工具–鲁迅”\nOCLint的目的\n   在开发过程中，特别是团队协作开发中，规范的重要性不言而喻，他可以降低沟通成本，增加代码可读性与可维护性提高可靠性与健壮性，作为一名优秀的开发人员，我们应该不断完善并严格遵守相关规范，但是实际情况是，由于我们的疏忽，或者工期的紧张等因素，导致在某些时候开发过程中变得随心所欲，代码变得为所欲为，进而对后期的维护造成不良影响，甚至原地crash&gt;_&lt;!，而OCLint可以帮助我们来检查代码是否遵守了某些规范，是否存在一些潜在的问题，降低review成本。\nOCLint能检测哪些问题\n附官方文档OCLint\n\n代码长度，过长或过短，包含方法，变量等\n未使用的代码，包括变量和方法\n代码复杂度，多重循环以及多重判断等\n语法错误\n\nOCLint安装\n   OCLint有多种安装方式，此处采取Homebrew安装，so 默认你的电脑已经安装了Homebrew,如果没安装，请先去安装Homebrew,一次就够，你会爱上它的😊\nbrew tap oclint/formulaebrew install oclint\n  为什么要执行第一句？因为要先安装OCLint的依赖，否则会报错，安装结束执行：\noclint --version\n  如果出现类似下面的信息，说明安装成功\nLLVM (http://llvm.org/):LLVM version 5.0.0svn-r313528Optimized build.Default target: x86_64-apple-darwin18.6.0Host CPU: skylakeOCLint (http://oclint.org/):OCLint version 0.13.Built Sep 18 2017 (08:58:40).\n  紧接着安装xcpretty这个东西是什么呢？它可以格式化xcodebuild的输出，增加可读性并可以生成报告,执行下面命令安装\nsudo gem install xcpretty\n   安装结束检查是否安装成功\nxcpretty -v\n   如果出现类似下面的版本号信息说明安装成功\n0.3.0\nOCLint使用\n   OCLint作为静态代码检测工具是可以直接在Xcode中使用的，也可以在终端进行操作，本文介绍的是终端操作方式，Xcode使用后续补充；首先进入项目根目录执行如下命令：\nxcodebuild clean xcodebuild analyze | tee xcodebuild.log \n  这一步会对项目进行分析并会在根目录生成一个build目录，并将分析日志输出在xcodebuild.log文件中\nxcodebuild |xcpretty -r json-compilation-database -o compile_commands.json \n  这一步是将编译结果输出在compile_commands.json文件中,这里有一个点要注意的就是，如果你已经编译过并将结果输出在compile_commands.json中，那么再次编译时已编译过的内容是不会被覆盖的，如果希望每次都重头操作，那么可以使用xcodebuild clean命令清除缓存，这也是第一步执行此命令的原因。\n  最后一步是将分析结果生成报告，这中间就会用到各种校验规则了，OCLint默认有些规则，包含了可能出现的大部分场景，当然也可以根据OCLint提供的方法自定义规则,执行如下命令生成报告\noclint-json-compilation-database -e Pods -- -report-type html -rc CYCLOMATIC_COMPLEXITY=5 -rc TOO_MANY_PARAMETERS=8-rc NESTED_BLOCK_DEPTH=5-rc LONG_LINE=200 -rc NCSS_METHOD=50-rc LONG_VARIABLE_NAME=30 -rc SHORT_VARIABLE_NAME=2-rc LONG_CLASS=1500-rc LONG_METHOD=150-disable-rule ShortVariableName -max-priority-1=10000 -max-priority-2=10000 -max-priority-3=10000 &gt; report.html\n  最终会在根目录生成一个report.html文件，点击打开可查看分析结果，大概是下面这个样子\n\n  另外上述出现的操作命令为了简便写了一个脚本，仅做参考，需要的自取\n  因为我此处只是为了展示，所以创建了一个空项目，并没有写内容，所以分析报告一片空白😂😂😂\n  本篇文章只做OCLint使用的初步介绍，实际上我在安装使用的过程中遇到了很多必然或偶然的坑，另外对于OCLint也并没有做详细的介绍，比如OCLint默认规则的介绍，如何自定义规则，相关套件的作用，以及OCLint的缺点等等，随后有时间我会一一整理补充上来。嗯，就酱~\n","categories":["开发"],"tags":["OCLint"]},{"title":"Pod库创建流程（上）","url":"/posts/440b4e19/","content":"\n[toc]\n创建pod库流程(上)\n第一步\n创建本地私有库，pod lib create 为创建pod模板工程命令``DYTest为私有库名称\npod lib create DYTest\n结果如下图所示,命令默认会在当前所在目录下创建，图中所示路径为桌面\n\n第二步\n创建远程仓库，进入刚才创建的DYTest工程根目录将本地创建的私有库工程与远程仓库关联起来，具体操作如下所示：\n\n第三步\n创建远程Spec文件仓库并添加到到本地repo目录，repo目录在本地cocoapods安装目录下，Spec文件为pod工程描述文件，里边可编辑pod库的所有配置信息，名称，地址，支持平台，版本，依赖库等等.\npod repo add为本地pod添加spec文件命令DYTestSpecs为要添加的spec目录的名称http://192.168.120.30/iOS_Group/DYTestSpecs.git为远程Spec文件仓库地址。\n注意：一个Spec文件仓库可以存放多个pod库的Spec文件\npod repo add DYTestSpecs http://192.168.120.30/iOS_Group/DYTestSpecs.git\n结果如下:\n\n第四步\n至此我们便可以着手在pod库里进行代码编写工作，由此流程创建的pod库文件根目录结构大概如下图所示：\n\n其中Example文件夹为pod模板自带的示例工程，我们在pod库中编写的代码可通过此示例工程进行调试，DYTest文件夹为我们将要编写代码的物理路径，目录结构如下:\n\nClasses文件夹即我们编写的pod库代码所在的文件物理路径\n下面我们打开项目看一下：\n\n其中创建时路径不要选错，是在Classes文件夹下箭头所指的文件为我们当前pod库的spec文件，将来如果要发布被他人搜索使用就需要编写此spec文件对应信息并将其推送单刚才创建的远程spec仓库DYTestSpecs中。\n绿色箭头所指为我们的Example示例工程目录。\n红色箭头所指为我们pod库工程代码目录，此目录为虚拟文件夹，其下文件物理路径为前文所述的Classes文件夹,一定要注意创建文件时候不要选错存放路径，应该存放在Classes下。\n每当我们添加新的文件时需要进入Example目录下进行update操作，这样创建的文件会自动加入工程，不进行update操作你的文件在使用时将会提示not found,具体操作如下所示:\n\n创建时路径不要选错，是在Classes文件夹下\n下面进行update操作\n\n注意路径，是在Example目录下进行update,完成后我们新创建的文件就可以import使用了\n当一天的工作完成后需要进行代码提交，那么我们进入项目根目录进行代码提交，\n\n分支根据情况自行选择，此处我选择master，pod库创建的简单流程及代码编写大体就这样，下次详细说一下spec文件的编写以及pod库某一阶段完成后打tag，进行推送以供他人search``install的流程。\n","categories":["开发"],"tags":["Cocoapods"]},{"title":"Pod库创建流程（下）","url":"/posts/fcb7297c/","content":"\n [TOC]\n创建pod库流程(下)\n前边讲了pod库默认工程模板的创建，文件添加存放路径，代码编写位置等基本信息，今天简单说下spec文件的编写及推送。\n第一步\n首先我们打开pod库的spec文件,以DYTest项目为例：\n\n其中红色箭头所指的就是项目的spec文件，红色方框内就是pod默认的spec文件的内容，里边有很多字段分别对应不同的配置信息，但一般来说我们只需要配置其中的几项就可以，其他的可以暂时删掉。\n删完之后大概如下图：\nPod::Spec.new do |s|  s.name             = &#x27;DYTest&#x27;  s.version          = &#x27;0.1.0&#x27;  s.summary          = &#x27;A short description of DYTest.&#x27;  s.description      = &lt;&lt;-DESCTODO: Add long description of the pod here.                       DESC  s.homepage         = &#x27;https://github.com/lazyloading@163.com/DYTest&#x27;  s.license          = &#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125;  s.author           = &#123; &#x27;lazyloading@163.com&#x27; =&gt; &#x27;lazyloading@163.com&#x27; &#125;  s.source           = &#123; :git =&gt; &#x27;https://github.com/lazyloading@163.com/DYTest.git&#x27;, :tag =&gt; s.version.to_s &#125;  s.ios.deployment_target = &#x27;8.0&#x27;  s.source_files = &#x27;DYTest/Classes/**/*&#x27;  # s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;end\n其中\n\n\ns.name : 你所创建的库的名字，比如Masonry，AFNNetworking等等\n\n\ns.version ： 库的版本号\n\n\ns.summary ： 简短的描述信息\n\n\ns.description ： 比简短描述长一点的描述信息\n\n\ns.homepage ： pod库远程仓库主页地址 我们此次的示例工程的主页就是 http://git.zhcs.com/iOS_Group/DYTest\n\n\ns.license ： 遵守的协议\n\n\ns.author ： 创建人\n\n\ns.ios.deployment_target ： 支持的系统版本版本此次示例工程支持到iOS 8.0\n\n\ns.source ： 你的pod库的远程仓库路径，我们此次的示例工程的路径就是http://192.168.120.30/iOS_Group/DYTest.git\n\n\ns.source_files = 要加入库中的代码在工程中的路径，此次示例工程编写的代码就在之前强调的'DYTest/Classes/**/*'路径下\n\n\n第二步\n当库每个版本代码编写完成后我们需要将pod库代码提交到对应的远程仓库，同时对应的spec文件也要推送到spec文件远程仓库。\n第一步我们完成了spec文件的编写，第二步我们就要推送spec文件，此次示例工程我们的spec文件远程仓库就是我们前文所创建的http://192.168.120.30/iOS_Group/DYTestSpecs.git\n我们先对spec文件做一个本地校验看看是否有配置错误：\n进入spec文件所在目录\n\n执行命令\npod lib lint \n当你在spec文件所在目录并且只有一个spec文件时候你可以这么写，否则你需要指定你要校验的spec文件用如下写法\npod lib lint DYTest.podspec\n执行结果如下：\n\n第一次执行pod lib lint 未成功，报出了⚠️其实这些警告可以忽略，我们只需要加上--allow-warnings参数，可以看到我们第二次执行成功了，如果你想看校验过程还可以在后边添加--verbose参数\n但是只是做本地校验还不够，毕竟我们的库并不是自己玩玩，是需要让其他人也用的，这就需要推送的远端，远端推送之前就需要进行远端校验，不仅查看语法是否正确，也查看你在远端的代码版本和spec文件中的是否匹配。\n我们先给代码打个tag,然后把tag推送到远程，tag版本需要和spec文件中的s.version一致，此处前边我们spec文件中s.version写的是0.1.0\n\n\n至此tag已经打完并推送成功，接下来就是对spec文件进行远程校验\n操作和本地校验类似只不过命令不同，执行命令\npod spec lint --allow-warnings\n结果如下\n\n或者我们很自信spec文件绝对没问题，这时候也可以不校验直接推\npod repo push DYTestSpecs *.podspec --sources=http://192.168.120.30/iOS_Group/DYTestSpecs.git,https://github.com/CocoaPods/Specs.git --use-libraries --allow-warnings --verbose\n结果如下:\n\n一次成功，完美，这里忍不住给自己鼓掌，整个操作行云流水一气呵成如德芙版丝滑中途没出现一点意外和错误，嘴角不自觉扬起了迷人的弧度\n\n不过这句命令很长有必要给大家解释下每一部分的含义不然你只会知其然不知其所以然，看看看看，出口成章，小伙子学着点以后要多读书啊。\n其中DYTestSpecs是我们第一篇里讲的，添加进本地repo目录下的示例工程对应的spec工程。\n*.podspec中*指通配符，这么写指以.podspec为后缀的文件,你也可以指定对应的spec文件，比如我们的示例工程就可以写成 DYTest.podspec。\n--sources指的是要将本地repo目录下DYTestSpecs工程推送的远端路径，如果你只想公司内部使用就可以不写后边的https://github.com/CocoaPods/Specs.git\n第三步\n创建，编写，校验，推送都完成了，接下来就是使用了，我们先search试一下看能不能搜到我们的库\npod search DYTest\n\n嗯，放心了，搜索的到，那么，接下来，就不用我多说了吧，开始愉快的使用吧~\n**后记：**这两篇文章主要说的是私有pod库的创建，编写及推送流程，实际具体使用过程中可能还会遇到其他问题导致你用的头大，比如操作顺序出错导致配置了不可逆的错误环境，操作的天时不对，坐的位置风水不好等等，总之就是很多不可控，玄学问题，这个在这篇文章就不一一细说，后边有问题可以直接问，或者有时间转门写一下。\n","categories":["开发"],"tags":["Cocoapods"]},{"title":"初识Flutter总结","url":"/posts/9bd452f5/","content":"\n[toc]\nFlutter是什么\n\nFlutter是一个基于Dart语言的跨平台UI框架，目前支持的平台有iOS，android，Web，Mac OS，Windows，Linux，强调这个是因为有部分初学者没接触的时候认为Flutter是一门语言，这是不正确的\n\n环境搭建\n\nMac和Linux系统设备建议使用Homebrew执行如下命令安装，Windows的话，去看教程\n\nbrew install flutter\n\n安装完默认路径一般为/usr/local/Caskroom/flutter/2.2.0/flutter这个样子\n网上有一大堆的教程去叫你怎么搭建环境，这里重复的原因是因为，如果你去按照网上的教程去搭建环境，会感觉，很繁琐，真的很繁琐，特别是iOS开发人员，为什么搭建环境一定要那么多步骤？而Homebrew让这一切变得很简单，只需要一行命令，然后等待网络下载完成就是了\n\n平台支持\n\n已Android studio为例，创建项目时，默认支持iOS和Android，但是可勾选支持Web，Linux和Windows ，Mac OS为不可选，如果需要支持可手动进行配置，命令如下，之后再创建项目就可以勾选相应的其他平台\n\nflutter config --enable-windows-desktopflutter config --enable-macos-desktopflutter config --enable-linux-desktop\n\n如果想要在已有的项目中添加新的平台，进入项目根目录后执行如下命令\n\nflutter create .\n组件\n概括\n\n\nFlutter里的组件都是Widget，基本可以分为两大类StatefulWidget（可变）和StatelessWidget（不可变）,区别就在于前者可以通过对应的State类去改变内容，所以每一个StatefulWidget都要对应一个State，而后者初始化后就不能再进行改变\n\n\nFlutter框架本身的组件风格分为两种Material和Cupertino，前者是Google的设计风格，看一下安卓设备大概就能了解到是什么样子，后者是iOS风格也就是Apple的设计风格，网上的教程几乎都是以Material，我在学习的过程中也是使用Material风格的组件，不过这些只是Flutter内置的供你使用的组件，同一个UI你完全可以用这两种风格分别实现\n\n\n常用Widget\nFlutter中内置了几百个Widget，包含显示类的文字(Text)，图片(Image)等，也包含不直接显示的容器类Container，Row，Column等，当你入门后，对Flutter有了一定的认知，后续的使用中就是经验的积累，去识记更多的Widget，记得越多，开发越快，下面介绍几种常用的Widget，记住这几个后基本开发一个简单的App就没什么问题了\n\n\nMaterialApp： 一般用作根Widget，App启动后，main（入口）函数中执行的方法中需要提供\n\n\nScaffold： 顾名思义，他是Flutter提供的一个脚手架Widget，自带抽屉，导航等，方便你快速搭起App的结构\n\n\n\nContainer： 容器类Widget的一种，也是最常用的Widget之一，可以理解为iOS中的UIView\nRow： 横向布局容器，加入其中的子Widget会水平排列布局\nColumn： 纵向布局容器，加入其中的子Widget会纵向排列布局\nStack： 叠加布局布局容器，加入其中的子Widget会叠加起来排列布局\nListView： 市面上几乎所有的App都会使用的，列表Widget\nGridView： 卡片，瀑布流布局\nText： 文字展示\nImage： 图片展示\nTextButton： 文字按钮\nGestureDetector： 如果某个Widget想要响应点击等交互事件，即使它本身不具备交互功能，只要用此Widget包括就可以了\n\n示例：\n\n上面这样的一个布局，觉得是怎样实现的?\n\n结构是这个样子的\n\n层级是这个样子的\n响应式\n\n\n在iOS中，iOS的框架本身是不支持响应式编程的，如果需要，则要借助第三方框架，比如OC的RAC，Swift的RxSwift等，这些框架由于不是官方提供，只是社区为了实现响应式而基于官方框架开发的应用框架，有相当高的额外学习成本\n\n\n而Flutter本身就是支持响应式的，这为我们的开发提供的很大的便利\n\n\n原生交互\n通过前面的介绍我么你知道Flutter本身是一个UI框架，如果涉及到一些非UI的比如相机拍照，必须要和Native交互调用硬件能力，那我们就必须和Native进行通信，Flutter中提供了三种通信方式\n\n\nMethodChannel： Flutter 与 Native 端相互调用，调用后可以返回结果，可以 Native 端主动调用，也可以Flutter主动调用，属于双向通信。此方式为最常用的方式， Native 端调用需要在主线程中执行。\n\n\nBasicMessageChannel： 用于使用指定的编解码器对消息进行编码和解码，属于双向通信，可以 Native 端主动调用，也可以Flutter主动调用。\n\n\nEventChannel： 用于数据流（event streams）的通信， Native 端主动发送数据给 Flutter，通常用于状态的监听，比如网络变化、传感器数据等。\n\n\nMethodChannel示例：\nFlutter端\n//Flutter端 初始化消息通道  static const MethodChannel _channel = const MethodChannel(&#x27;com.methodChannel&#x27;);    //Flutter调用  final Map test = await _channel.invokeMethod(&#x27;methodChannelSend&#x27;);\niOS端\n//swift端 初始化消息通道    let channel = FlutterMethodChannel(name: &quot;com.methodChannel&quot;, binaryMessenger: registrar.messenger())    //swift端 接收消息channel.setMethodCallHandler &#123; [weak vc](call,  result) in            if call.method == &quot;methodChannelSend&quot; &#123;                print(&quot;flutter给native发消息\\(call.arguments ?? (Any).self)&quot;)            &#125;        &#125;\n库和插件\nFlutter是一个UI框架，但是一个完整的App不只有UI展示，还有其他的能力，比如上边提到的硬件调用，录音，定位，网络请求，状态管理，数据持久化等等…这些能力中Flutter本身是不提供支持的，但是我们我们可以借助响应的库来实现，首先说一下库和插件的关系\n\n\n库是提供特定能力的开发工具包，可以是官方提供，也可以是三方提供\n\n\n插件是特殊的库，举个例子，比如仅提供iOS和Android调用的库，要知道Flutter支持的平台不止这两个\n\n\n引入库和插件需要在Flutter项目中的pubspec.yaml中进行配置，下面提供一个我的配置截图：\n\n这里要注意dev_dependencies和dependencies两者的区别，前者指的是，只在开发阶段生效，不参与编译的库，后者指的是，参与编译，运行需要依赖的库，他们是有区别的，举个例子build_runner,json_serializable配合使用的话，可以通过注解，结合如下命令，生成额外的xxx.g.dart文件来帮助我们快速的生成JSON转Model方法，但是xxx.g.dart这个文件只在开发过程中生成和更新，这个库的作用也仅仅是生产这个文件，所以build_runner它本身不参与编译\nflutter packages pub run build_runner build\n虽然都写在dependencies中项目也可以正常运行，但是这样的话打出来的包就会变得大一点，可以，但没必要\n下面举例一些开发常用的库:\n\ndio 三方网络库\nwebview_flutter官方维护的webview库\ncached_network_image图片加载库\nsqflite基于sqlite的轻量级数据库框架\npull_to_refresh下拉刷新上拉加载\nshared_preferences本地数据存储，适合少量数据\n\n图片资源\n\n我们在开发过程中不免要导入一些静态资源，比如图片，文本文件，音频文件等，我目前只用到了图片资源这里也只介绍图片资源的导入和使用，下面看一下我的图片引入截图，同样是在pubspec.yaml\n\n\n注意pubspec.yaml文件有着严格的格式要求，对齐有问题都会导致你导入失败，我当时就吃了系统模板的亏\n混编\n以上介绍的都是纯Flutter项目，什么意思，就是说整个项目的主体是Flutter编写，可能部分功能涉及到和Native交互，但是实际上，很多成熟的项目想要体验Flutter，但是又不敢将整个项目使用Flutter重构，毕竟这中间是有很大风险的，所以我们可以在原生项目中，引入Futter模块，将Native中的某个小模块用Flutter开发来进行体验，这样做的风险我们是可以接受的，下面举一个iOS和Flutter混编并用cocoapods引入的示例\n\n假设fluttermoduledemo是一个iOS原生项目\n\n//进入到fluttermoduledemo目录的上一级，执行如下命令flutter create --template module flutter_module\n\n\n其中flutter_module为需要导入iOS的Flutter模块名称，这个模块的目录结构和纯Fluter项目的结构几乎一样，只不过有几个文件夹变成了隐藏文件夹，编写Flutter代码和在纯Flutter项目中没有区别\n\n\n下面来看一下iOS项目如何引入\n\n\n//在iOS项目的Podfile文件中添加如下配置，其中第一行最后的flutter_module，就是上一步创建的Flutter模块的名称  flutter_application_path = &#x27;../flutter_module&#x27;  load File.join(flutter_application_path,&quot;.ios&quot;,&quot;Flutter&quot;,&quot;podhelper.rb&quot;)  install_all_flutter_pods(flutter_application_path);\n\niOS使用\n\n //在Delegate中初始化Flutter引擎 lazy var flutterEngine = FlutterEngine(name: &quot;ZMEngine&quot;) func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123;     flutterEngine.run()     GeneratedPluginRegistrant.register(with: self.flutterEngine);     return true &#125;  //在需要的地方，跳转Flutter模块let vc = FlutterViewController(engine:self.flutterEngine, nibName: nil, bundle: nil) self.present(vc,animated: true, completion: nil);\n未完内容\n\n另外还有一些内容也很重要，但是我这里没有展开说的原因是因为，我现在自己也没有搞得很明白，仅仅处于会用的阶段，比如Future涉及到Dart的线程机制，比如状态管理等，我听过一句话唯有深入，才能浅出，而现今我还没有非常深入，所以干脆就不讲，以免误人子弟，只做一个印象级概括\n\n学习参考文档\nFlutter学习文档\nDart学习文档\nFlutter Package\n结尾\n这个文档只是我去学Flutter后遇到的一些问题的理解，以及对Flutter整个框架粗略的概括，并非完整教程，类似于你去看电视剧，你需要一集一集的追下去，然后直到结局才能窥见全貌，而这个文档相当于一种剧透，或者说剧情的概括，看完之后脑海中与一个大体的轮廓，这个Flutter是个什么东西，然后你可以去详细的，认真的跟着教程去学习，丰富轮廓内的内容。\n","categories":["开发"],"tags":["Flutter"]},{"title":"iOS15推送后台语音播报探索","url":"/posts/6fd361a9/","content":"meta \n前言\n前一段时间公司项目有个推送内容语音播报的需求，当时让做技术调研，简单搜了下相关的文章和资料，调研一半的时候突然来了优先级更高的需求，搁置了，这两天空下来，所以继续看，并且有了可行的方案。\n调研后发现这个需求用到Notification Service Extension，网上有一些文章讲这个需求的实现，但是绝大多数讲的方案现在已经不适用了或者是只提供一个大致的思路没有具体的实现，所以把我实现这个需求的过程记录分享出来\nNotification Service Extension\nNotification Service ExtensioniOS10之后才能使用，如果要想使用Notification Service Extension对通知内容进行更改，需要在推送中增加mutable-content字段并将值设置为true，使用通知扩展后推送的处理流程如图所示\n\n创建步骤如下图所示\n\n\n完成后会在项目中生成一个target和对应的文件夹，我们的代码就要卸载NotificationService.m中\nNotificationService.m文件内部有两个方法，我们可以在这个方法中对通知内容进行修改\n// Call contentHandler with the modified notification content to deliver. If the handler is not called before the service&#x27;s time expires then the unmodified notification will be delivered.// You are expected to override this method to implement push notification modification.- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent *contentToDeliver))contentHandler\n在这个方法中做通知扩展终止前的兜底处理\n// Will be called just before this extension is terminated by the system. You may choose whether to override this method.- (void)serviceExtensionTimeWillExpire;\n到此Notification Service Extension创建完成\n播报探索\n系统语音合成\n系统提供的有文字转语音播报的方法，我们在收到推送后可以传入文字直接播报出语音\n- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123;    self.contentHandler = contentHandler;    self.bestAttemptContent = [request.content mutableCopy];        // Modify the notification content here...    self.bestAttemptContent.title = [NSString stringWithFormat:@&quot;%@ [modified]&quot;, self.bestAttemptContent.title];    NSString *content = self.bestAttemptContent.userInfo[@&quot;aps&quot;][@&quot;alert&quot;][@&quot;body&quot;];    AVSpeechUtterance *utterance = [AVSpeechUtterance speechUtteranceWithString:content];    AVSpeechSynthesisVoice *voice = [AVSpeechSynthesisVoice voiceWithLanguage:@&quot;zh-CN&quot;];    utterance.voice = voice;    AVSpeechSynthesizer *synth = [[AVSpeechSynthesizer alloc] init];    [synth speakUtterance:utterance];    self.contentHandler(self.bestAttemptContent);&#125;\n网上大部分文章也会这么写，但是现在实际应用中基本不会用这个方案原因有两个：\n\niOS12.1之后系统限制了在扩展里进行播报的能力，所以此方案只能用在iOS12.1之前\n语音生硬，并且多音字和英文字母在汉语语境下经常读错，比如字母E会读成额的音(这个我同一套代码在不同设备上读音不一致，没找到原因)，还是三方服务效果好点&gt;_&lt;!\n\n内置本地音频\n后来就想，不能语音合成，那播放本地语音呢？\n- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123;    self.contentHandler = contentHandler;    self.bestAttemptContent = [request.content mutableCopy];        // Modify the notification content here...    self.bestAttemptContent.title = [NSString stringWithFormat:@&quot;%@ [modified]&quot;, self.bestAttemptContent.title];    NSString * voiceType = self.bestAttemptContent.userInfo[@&quot;voiceType&quot;];    UNNotificationSound * sound = [UNNotificationSound soundNamed:[NSString stringWithFormat:@&quot;%@.mp3&quot;,voiceType]];    self.bestAttemptContent.sound = sound;    self.contentHandler(self.bestAttemptContent);&#125;\n扩展类中有个bestAttemptContent属性，他是UNMutableNotificationContent类型，我们在修改推送内容时也是对它进行修改，而播放本地语音就是修改它的sound属性，但是这个时候产品跳出来了，说对这样的实现不太满意，太死板，只能播放固定的音频不够灵活😂，没办法只能继续看\n然后就想把播报内容拆开，本地内置几段语音，根据推送内容进行拼接，然后修改sound进行播报，我先随便找了两段比较短的音频内置进项目进行测试\n-(void)audioMergeClick&#123;    //1.获取本地音频素材    NSString *audioPath1 = [[NSBundle mainBundle]pathForResource:@&quot;1&quot; ofType:@&quot;mp3&quot;];    NSString *audioPath2 = [[NSBundle mainBundle]pathForResource:@&quot;2&quot; ofType:@&quot;mp3&quot;];    AVURLAsset *audioAsset1 = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:audioPath1]];    AVURLAsset *audioAsset2 = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:audioPath2]];    //2.创建两个音频轨道,并获取两个音频素材的轨道    AVMutableComposition *composition = [AVMutableComposition composition];    //音频轨道    AVMutableCompositionTrack *audioTrack1 = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:0];    AVMutableCompositionTrack *audioTrack2 = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:0];    //获取音频素材轨道    AVAssetTrack *audioAssetTrack1 = [[audioAsset1 tracksWithMediaType:AVMediaTypeAudio] firstObject];    AVAssetTrack *audioAssetTrack2 = [[audioAsset2 tracksWithMediaType:AVMediaTypeAudio]firstObject];    //3.将两段音频插入音轨文件,进行合并    //音频合并- 插入音轨文件    // `startTime`参数要设置为第一段音频的时长，即`audioAsset1.duration`, 表示将第二段音频插入到第一段音频的尾部。        [audioTrack1 insertTimeRange:CMTimeRangeMake(kCMTimeZero, audioAsset1.duration) ofTrack:audioAssetTrack1 atTime:kCMTimeZero error:nil];    [audioTrack2 insertTimeRange:CMTimeRangeMake(kCMTimeZero, audioAsset2.duration) ofTrack:audioAssetTrack2 atTime:audioAsset1.duration error:nil];    //4. 导出合并后的音频文件    //`presetName`要和之后的`session.outputFileType`相对应    //音频文件目前只找到支持m4a 类型的    AVAssetExportSession *session = [[AVAssetExportSession alloc]initWithAsset:composition presetName:AVAssetExportPresetAppleM4A];        NSString *outPutFilePath = [[self.filePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@&quot;test.m4a&quot;];        if ([[NSFileManager defaultManager] fileExistsAtPath:outPutFilePath]) &#123;        [[NSFileManager defaultManager] removeItemAtPath:outPutFilePath error:nil];    &#125;    // 查看当前session支持的fileType类型    NSLog(@&quot;---%@&quot;,[session supportedFileTypes]);    session.outputURL = [NSURL fileURLWithPath:self.filePath];    session.outputFileType = AVFileTypeAppleM4A; //与上述的`present`相对应    session.shouldOptimizeForNetworkUse = YES;   //优化网络    [session exportAsynchronouslyWithCompletionHandler:^&#123;        if (session.status == AVAssetExportSessionStatusCompleted) &#123;            NSLog(@&quot;合并成功----%@&quot;, outPutFilePath);            UNNotificationSound * sound = [UNNotificationSound soundNamed:@&quot;test.m4a&quot;];            self.bestAttemptContent.sound = sound;            self.contentHandler(self.bestAttemptContent);        &#125; else &#123;            self.contentHandler(self.bestAttemptContent);        &#125;    &#125;];&#125;\n然后，推送过来后播报的还是默认声音😳，于是开始找原因，一开始以为是文件格式的问题，于是把m4a转化成mp3(省略代码)，还是不行，最后找到了一片文章（感谢大佬），文章说sound读取本地音频不是所有路径都可以，是有优先级的\n\n主应用中的文件夹\nAppGroups共享目录中的Library/Sounds文件夹\nmain bundle\n\n根据这个说法我开始测试，首先是第一条，我打印出APP沙盒Library下所有目录\n\nLibrary/Sounds\n\n看到里边的Sounds目录了吧，这是我创建的，之前并没有，然后修改合成文件的保存路径，重新走起！\n\n额，依然播报的是系统默认声音，短时间内没找到原因，于是直接看第二优先级\n\nAppGroups\n\n我们知道因为沙盒机制，iOS系统的App只能访问自己的文件夹，AppGroups就是苹果提供的同一开发者账号下多App资源共享的一种方案，最低支持iOS8，我们用的是企业签名，因为公司组织架构和权限的原因麻烦了一天才把一个简单AppGroups配置完成😭，这里就不贴具体的创建和配置过程了，网上相关的资料也很多了\n最终将上边的音频文件导出路径修改为AppGroups下的Library/Sounds\n[session exportAsynchronouslyWithCompletionHandler:^&#123;    if (session.status == AVAssetExportSessionStatusCompleted) &#123;        NSLog(@&quot;合并成功----%@&quot;, outPutFilePath);        UNNotificationSound * sound = [UNNotificationSound soundNamed:@&quot;test.m4a&quot;];        self.bestAttemptContent.sound = sound;        self.contentHandler(self.bestAttemptContent);    &#125; else &#123;        self.contentHandler(self.bestAttemptContent);    &#125;&#125;];\n记得判断文件夹是否存在，我这里简单贴一下AppGroups的操作吧\nNSURL *groupURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:kGroupDefaultSuiteName];    NSURL * sounds = [groupURL URLByAppendingPathComponent:@&quot;/Library/Sounds/&quot; isDirectory:YES];    if (![[NSFileManager defaultManager] contentsOfDirectoryAtPath:sounds.path error:nil]) &#123;        [[NSFileManager defaultManager] createDirectoryAtPath:sounds.path withIntermediateDirectories:YES attributes:nil error:nil];    &#125;\n最终，发起推送，播报成功，但这个方案产品虽然说可以但还是不太满意，于是，继续摸索\n最终方案\n那么总结下之前方案不行的原因：\n\n直接语音转文字播报，系统限制iOS12.1后播报能力\n固定音频，不够灵活产品不满意\n拆分固定音频，拼接后播报（同上）\n\n既然这样，能不能把上边几种方案的优点结合下？将文字转语音后的音频文件存到本地然后再去播报？这里得到了另一个大佬的指点（感谢大佬），尝试过后确认方案可行☺️\n查看了AVSpeechSynthesizer文档后没找到转音频文件的相关方法（可能是我眼拙，找到的请告诉我）于是去看了三方的能力，其中百度和科大讯飞的离线合成都提供了获取音频文件的方法，但是最终我用的是科大讯飞的，因为百度的只提供两个设备码供测试，科大讯飞的十个（格局打开）\n详细方法看科大讯飞文档，注册申请过程我这里就不赘述了，但是如果想用三方服务强烈建议先看文档！！！\n1. 初始化离线合成引擎\n//讯飞  [IFlySetting setLogFile:LVL_ALL];  [IFlySetting showLogcat:YES];  NSString *initString = [[NSString alloc] initWithFormat:@&quot;appid=%@&quot;, @&quot;你的appid&quot;];  [IFlySpeechUtility createUtility:initString];\n2. 设置参数\n_iFlySpeechSynthesizer = [IFlySpeechSynthesizer sharedInstance];  _iFlySpeechSynthesizer.delegate = self;  [[IFlySpeechUtility getUtility] setParameter:@&quot;tts&quot; forKey:[IFlyResourceUtil ENGINE_START]];  //设置本地引擎类型，普通版设置为TYPE_LOCAL，高品质版设置为TYPE_LOCAL_XTTS  [_iFlySpeechSynthesizer setParameter:[IFlySpeechConstant TYPE_LOCAL] forKey:[IFlySpeechConstant ENGINE_TYPE]];  //设置发音人为小燕  [_iFlySpeechSynthesizer setParameter:@&quot;xiaoyan&quot; forKey:[IFlySpeechConstant VOICE_NAME]];  //获取离线语音合成发音人资源文件路径。以发音人小燕为例，请确保资源文件的存在。  NSString *resPath = [[NSBundle mainBundle] pathForResource:@&quot;common&quot; ofType:@&quot;jet&quot;];  NSString *resPath1 = [[NSBundle mainBundle] pathForResource:@&quot;xiaoyan&quot; ofType:@&quot;jet&quot;];  NSString *vcnResPath = [[NSString alloc] initWithFormat:@&quot;%@;%@&quot;,resPath,resPath1];  //设置离线语音合成发音人资源文件路径  [_iFlySpeechSynthesizer setParameter:vcnResPath forKey:@&quot;tts_res_path&quot;];  [_iFlySpeechSynthesizer synthesize:content toUri:[self pcmPath]];\n其中-(void)synthesize:(NSString *)text toUri:(NSString*)uri方法就是离线合成后讲语音文件保存本地的方法，两个参数，第一个是要播报的文字内容，第二个是音频文件要存储的路径\n3. 获取本地音频\n这边有个问题就是离线合成的语音文件是pcm格式的，不仅是讯飞，百度也是一样，pcm我们是不能直接给sound播放的，所以我们要做一个格式转换，转成mp3进行播放，贴一个pcm转mp3方法，需要用的lame三方库\n/*** * pcm 文件转mp3文件 */- (BOOL)convertPcm:(NSString *)pcmPath toMp3:(NSString *)mp3Path &#123;    @try &#123;        FILE *fpcm = fopen([pcmPath cStringUsingEncoding:NSASCIIStringEncoding], &quot;rb&quot;);        if (fpcm == NULL) &#123;            return false;        &#125;//        fseek(fpcm, 1024*4, SEEK_CUR); //跳过源文件的信息头，不然在开头会有爆破音        FILE *fmp3 = fopen([mp3Path cStringUsingEncoding:NSASCIIStringEncoding], &quot;wb&quot;);        int channelCount = 1;   // 声道数, 跟录音时配置一样的        lame_t lame = lame_init();        lame_set_in_samplerate(lame, 16000); //设置采样率, 需要跟录音时的采样率相同        lame_set_num_channels(lame, channelCount); //声道，不设置默认为双声道        lame_set_VBR(lame, vbr_default);//        lame_set_mode(lame, 0);//设置最终mp3编码输出的声道模式，如果不设置则和输入声道数一样。参数是枚举，STEREO代表双声道，MONO代表单声道        lame_set_quality(lame, 2);//设置压缩品质，quality=0..9. 0=best (very slow). 9=worst. 品质越好转码速度越慢        lame_init_params(lame);        const int PCM_SIZE = 8192;//        const int MP3_SIZE = 8192; //        short int pcm_buffer[PCM_SIZE*channelCount];        unsigned char mp3_buffer[MP3_SIZE];        int read;        int write;        do &#123;            read = fread(pcm_buffer, channelCount*sizeof(short int), PCM_SIZE, fpcm);            if (read == 0) &#123;                write = lame_encode_flush(lame, mp3_buffer, MP3_SIZE);            &#125; else &#123;                if (channelCount == 1) &#123;                    write = lame_encode_buffer(lame, pcm_buffer, NULL, read, mp3_buffer, MP3_SIZE); // 单声道音频转码                &#125; else &#123;                    write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, MP3_SIZE); // 多声道音频转码                &#125;            &#125;            fwrite(mp3_buffer, write, 1, fmp3);        &#125; while (read != 0);        lame_mp3_tags_fid(lame, fmp3);        lame_close(lame);        fclose(fmp3);        fclose(fpcm);    &#125; @catch (NSException *exception) &#123;        NSLog(@&quot;catch exception, %@&quot;, exception);        return false;    &#125; @finally &#123;        return true;    &#125;&#125;\n最后在合成完成方法中做转换和播报处理\n- (void) onCompleted:(IFlySpeechError *) error &#123;    if (error.errorCode == 0) &#123;        NSURL *groupURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:kGroupDefaultSuiteName];        NSURL * sounds = [groupURL URLByAppendingPathComponent:@&quot;/Library/Sounds/&quot; isDirectory:YES];        if (![[NSFileManager defaultManager] contentsOfDirectoryAtPath:sounds.path error:nil]) &#123;            [[NSFileManager defaultManager] createDirectoryAtPath:sounds.path withIntermediateDirectories:YES attributes:nil error:nil];        &#125;        NSURL *mp3Path = [groupURL URLByAppendingPathComponent:@&quot;Library/Sounds/voice.mp3&quot; isDirectory:NO];        BOOL result = [self convertPcm:[self pcmPath] toMp3:mp3Path.path];        if (result) &#123;            if (@available(iOS 12.1,*)) &#123;                UNNotificationSound * sound = [UNNotificationSound soundNamed:@&quot;voice.mp3&quot;];                self.bestAttemptContent.sound = sound;                self.contentHandler(self.bestAttemptContent);            &#125;else&#123;                _player = [[AVAudioPlayer alloc] initWithContentsOfURL:mp3Path error:nil];                [_player play];                self.contentHandler(self.bestAttemptContent);            &#125;        &#125;else&#123;            self.contentHandler(self.bestAttemptContent);        &#125;    &#125;else&#123;        self.contentHandler(self.bestAttemptContent);    &#125;&#125;\n这里依然做了系统区分，因为实际测试后发现，iOS11的系统设置合成音频给sound后还是播放的默认声音，后来发现有人遇到类似的问题，iOS10-iOS12系统无法在推送扩展里读取到AppGroups中的音频文件，之前手边只有iOS15系统的测试机，没有发现这个问题，所以最后在依然做了区分处理低版本系统用AVAudioPlayer播放合成音频\n实现总结\n\n创建Notification Service Extension以实现对推送消息做最后的修改\n添加AppGroup\n将要播报的文字内容用离线合成转成音频文件并存入AppGroup内的/Library/Sounds下\n修改bestAttemptContent的sound为存入本地的音频文件\n\n虽然实现这个需求废了些时间，但是实现后回头看看，也就几步😂😂😂\n注意点\n\nExtension是单独的进程，离线合成引擎要在Extension中启动\nExtension启动后只有约30s时间供你操作，超时会播放默认声音\n推送内容要添加mutable-content字段并将值设置为true\n\n参考文章\niOS小技能：消息推送扩展的使用\niOS13微信收款到账语音提醒开发总结\n","categories":["开发"],"tags":["iOS"]},{"title":"iOS模拟器推送测试及踩坑","url":"/posts/b766a676/","content":"前言： 现在的App几乎都有推送功能，开发推送功能的时候我们肯定要进行测试，但是之前推送功能只有在真机上才能测试，在Xcode11.4之后，模拟器也支持推送测试，具体操作如下：\n1.创建推送文件\n内容类似如下格式\n&#123;    &quot;aps&quot;:&#123;        &quot;alert&quot;:&#123;            &quot;title&quot;:&quot;标题&quot;,            &quot;body&quot;:&quot;内容辱与共产主义不容辞&quot;        &#125;,        &quot;content-available&quot; : 1,        &quot;mutable-content&quot; : 1    &#125;&#125;\n具体格式根据你们的产品要求，接入极光或者个推的可以在控制台发一条推送打印出具体格式内容查看,将文件保存后缀为apns，待会要用到\n2.执行如下命令进行测试\n\n查看已启动模拟器\n\nxcrun simctl list devices | grep Booted\n会看到类似下面信息，如果没有请先启动模拟器\niPhone 12 Pro (1BEE4182-C934-431E-BCBF-F7676C4C2BFC) (Booted)\n\n运行项目在模拟器上后执行相应命令simctl push &lt;device&gt; [&lt;bundle identifier&gt;] (&lt;json file&gt; | -)\n\n示例如下\nxcrun simctl push Booted com.app.test /Users/lazyloading/Desktop/payload.apns\n3.另外还有一种方式是直接使用推送文件\n将第一步创建的json文件内容稍加修改,具体就是添加了   &quot;Simulator Target Bundle&quot;: &quot;com.app.test&quot;你项目的包名\n&#123;    &quot;Simulator Target Bundle&quot;: &quot;com.app.test&quot;,    &quot;aps&quot;:&#123;        &quot;alert&quot;:&#123;            &quot;title&quot;:&quot;标题&quot;,            &quot;body&quot;:&quot;内容辱与共产主义不容辞&quot;        &#125;,        &quot;content-available&quot; : 1,        &quot;mutable-content&quot; : 1    &#125;&#125;\n然后直接拖动文件到模拟器上，出现绿色➕后松手，这样也可以进行推送测试\n踩坑\n到这里按照网上你查看的其他教程应该已经收到测试的推送了，但是我没有&gt;_&lt;!\n原因很简单，没有注册，我的项目中集成的是极光推送，已经存在注册步骤，但是这里依然要我注册，如果你遇到类似的问题，添加如下代码\n[UNUserNotificationCenter.currentNotificationCenter requestAuthorizationWithOptions:UNAuthorizationOptionAlert | UNAuthorizationOptionSound  completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;        NSLog(@&quot;%d&quot;,granted);&#125;];\n这是应该就可以正常收到推送了，但是依然存在几个问题，推送相关的代理方法没有执行，iOS15真机可以，模拟器不行，例如\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler \n另外就是前台没法收到推送，退到后台才可以，至少我这里遇到的情况是这样，虽然模拟器支持推送测试，但是依然无法和真机进行比较，最好还是以真机测试为准\n","categories":["开发"],"tags":["iOS"]},{"title":"《人类简史：从动物到上帝》随性笔记","url":"/posts/6e29e650/","content":"《人类简史：从动物到上帝》笔记\n这本书是年前看视频还是刷微博什么的看到别人推荐的，忘了，记录下看书过程中记下的笔记（和吐槽），持续随性阅读更新\n第一部分 认知革命\n第二章 知善恶树\n\n通过文字创造出想象的现实，就能让大批互不相识的人有效合作，而且效果还不只如此。正由于大规模的人类合作是以虚构的故事作为基础，只要改变所讲的故事，就能改变人类合作的方式。\n\n脑海中突然冒出个想法，传销吗这不是haha~\n第三章 亚当和夏娃的一天\n\n在现代的富裕社会，平均每周的工时是40~45小时，发展中国家则是60甚至80小时；但如果是狩猎采集者，就算住在最贫瘠的地区（像是卡拉哈里沙漠），平均每周也只需要工作35~45小时。他们大概只需要每三天打猎一次，每天采集3~6小时\n\n现代人社畜无疑了~\n\n也因为采集者不依赖单一种类的食物，就算某种食物来源断绝了，影响也不会太大。但如果是农业社会，一旦来场干旱、火灾、地震，把当年的稻子或马铃薯摧毁殆尽，就会引发严重的饥荒。虽然采集社会还是难以幸免于自然灾害，而且也会碰上食物短缺或饥荒的情形，但通常他们处理起来就是比较游刃有余\n\n这点我不能同意，人类进入农业社会就是为了解决食物短缺开源不稳定的问题，这也是自然选择导致的生存方式变化，人类发现农业之前的采集社会食物开源虽然多样但是不稳定，吃了上顿没下顿，抵抗自然灾害的能力更差，看看现在的各种野生动物，难道在食物上都比人类富足？或者去看几百年前北方的游牧民族，不断进入中原农业社会掠夺，如果这种生存方式更优越，为什么他们会如此做？\n第二部分 农业革命\n第五章 史上最大骗局\n\n第一，小麦不喜欢大小石头，所以智人得把田地里的石头捡干净搬出去，搞得腰酸背痛。第二，小麦不喜欢与其他植物分享空间、水和养分，所以我们看到男男女女在烈日下整天除草。第三，小麦会得病，所以智人得帮忙驱虫防病。第四，不论是蝗虫还是兔子，都不排斥饱尝一顿小麦大餐，但小麦完全无力抵抗，所以农民又不得不守卫保护。最后，小麦会渴，所以人类得从涌泉或溪流大老远把水引来，为它止渴；小麦也会饿，所以智人甚至得收集动物粪便，用来滋养小麦生长的土地。\n\n作者一直在阐述采集社会优于农业社会，或者说单就食物这方面说，优于农业社会，包括在多样性和稳定住方面，我不能苟同，早先多样性是因为没得吃，什么能吃吃什么，总的来说就是吃点东西别让自己饿死，并且农业社会后并不是就不具备多样性了，而是变得以某几种为主，并没有说拒绝吃其他食物，并且，从采集到农业有两个很大的优点是促使人类彻底转变的原因，一个是安全，一个是稳定，采集狩猎社会获取食物，你需要和野兽斗智斗勇，试试小心别让自己受伤，以那个时候的医疗条件，受伤严重点基本等于已经死了，人们都是趋利避害的，而农业种植的安全性要远大于采集狩猎，另一个稳定，前文作者也说了，人类是种族灭绝的元凶，原始社会的人类并没有可持续发展的观念，遇到什么能吃什么就打来吃，他们不知道竭泽而渔的道理（并不绝对），那么可采集狩猎的食物在较长的时间跨度里，是在慢慢减少的，这也是他们不断迁徙的原因之一，看看现在的许多动物仍是如此，而这种情况下的农业种植，恰恰提供了持续的产出，或许他们不懂得可持续发展的道理但是一季又一季的种植，不断的收获，这是看的到的产出；作者虽然说会容易收到自然灾害病虫害的影响，首先自然灾害都是区域性大面积的，如果真有自然灾害，难道只影响你的耕地？不影响你原始的食物采集区？显然不是的，天地不仁以万物为刍狗，大自然和你非亲非故不会特殊照顾你，至于什么平整土地刨除石头之类得，这些工作的难度依然小于采集狩猎，并且是一次性的，一片土地的石头刨除后，明年有不会再长出来对不对？而植物养料的获取难度在人类定居在耕地附近后其实容易获取，难道采集社会的职务就不需要粪便养料？那时候难道不是更难获取？归根结底农业种植活动其实就是固定一片区域的采集狩猎活动，采集的是你种植的植物，狩猎的是你圈养的动物，只不过变得更加稳定和安全了。\n","categories":["随笔"],"tags":["读书笔记"]},{"title":"Homebrew 安装Mysql密码忘记解决","url":"/posts/ed9ccb24/","content":"我的Mac很久之前安装了mysql，当时设置了密码，最近重新想起来用，但是忘记了密码，网上找了很多文章，千篇一律几乎都是复制粘贴，个别过分的就贴一个链接完事，找了很久终于找到了解决方案，所以做个记录，免得遇到同样问题的人跟我一样找半天解决方案\n5.8及之前，网上文章几乎都是针对此种情况\n第一步\n因为忘记密码无法启动，所以执行下面命令进入安全启动模式\nmysql.server start --skip-grant-tables\n第二步\n登录\nmysql -uroot\n第三步\n此时进入mysql下\nuse mysql\n第四步\n接着执行\nFLUSH PRIVILEGES; \n第五步\n设置密码\nSET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;你的新密码&#x27;);\n退出mysql，杀掉进程，重新启动\n5.8之后，我的是8.0.25\n前四步操作同上\nALTER user &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;你的新密码&#x27;;\n退出mysql，杀掉进程，重新启动即可正常登陆\n文档\n","categories":["开发"],"tags":["Mysql"]},{"title":"load和initialize区别","url":"/posts/a696ae61/","content":"[TOC]\n最近在群里突然有群友问load和initialize区别，我心想这不简单吗，脑海中瞬间冒出两条，然后就想不起来了，然后看到群友七嘴八舌一人一个说法，我就寻思重新回顾下这个知识点，遂做个回顾。\n这篇文章是我结合网上资料，官方文档，和runtime源码整理得出的，在说明结论时我会在结论前附带官方文档解释并会在（）附带自己的理解，如果理解有误还请指正；你也可以写个demo去验证，我顺手在项目中验证了下所以就不贴代码了。\n调用方式\n\n\nOBJC_EXPORT void _objc_load_image(HMODULE image, header_info *hinfo)\n{\nprepare_load_methods(hinfo);\ncall_load_methods();\n}\n可以下载源码(objc4-818.2源码)点objc-os文件进去查看_objc_load_image -&gt; call_load_methods -&gt; call_load_methods -&gt; call_class_loads -&gt; (*load_method(cls,@selector(load));\n\n\n\nload通过函数地址调用\n\n\n\nThe runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.\n\n\n\ninitialize通过objc_msgSend（runtime消息发送）调用\n\n调用时机\n\n\nInvoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.\n\n\n\nload是runtime加载类、分类的时候调用(只会调用一次)\n\n\n\nInitializes the class before it receives its first message.\nThe superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].\n\n\n\ninitialize是类第一次接收到消息的时候调用（可以在main前也可以在后，看什么时候第一次接收消息）, 每一个类只会initialize一次(如果子类没有实现initialize方法, 会调用父类的initialize方法, 所以父类的initialize方法可能会调用多次)\n\n以上的调用一次指的是程序生命周期内默认只调用一次，但是如果你手动调用的话还是会调用多次\n调用顺序\n\n\nA class’s +load method is called after all of its superclasses’ +load methods.\nA category +load method is called after the class’s own +load method.\n\n\n\nload\n\n先调用类的load, 再调用分类的load\n先调用父类的load，再调用子类的load\n先编译的类（分类），先调用\n\n\n\n\n\nThe runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.\nThe superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].\n\n\n\ninitialize\n\n先调用父类，再调用子类（即使你先给子类发消息，子类默认也会先调用父类）\n如果子类没实现initialize，会向上调用父类\n如果分类实现initialize，则会覆盖本类的initialize（因为是objc_msgSend消息发送调用，分类方法加载时会插入在本类前）\n\n\n\n资料\n\n如果你不清楚怎么查看官方文档:\n  Xcode -&gt; Help -&gt; Developer Documentation\n或者你也可以下载Dash查阅\n如果你想查看源码：\nruntime源码下载\n\n","categories":["开发"],"tags":["iOS"]},{"title":"快进来找个地方坐下，一个移动端老菜鸟的2021年度总结","url":"/posts/9983e3c6/","content":"前言： 想一想，参加工作已经五年了，还从没有给自己写过年度总结（只写过公司要求的那种），最近在群里看到各位群友都在写年度总结，看了几篇后感觉挺有意思，字里行间的喜怒哀乐，让我感觉非常亲切，这就是生活的味道啊，所以，不自觉地就开始回想起自己这一年的经历，遂动手写下了了这篇自己人生中第一篇年度总结。\n回首2021\n工作\n进入目前公司是在去年国庆节前后，当时项目紧，并且公司对那个项目也非常重视，所以我们几个移动端一一起参与进去加了一段时间的班，到去年底今年初的时候，公司启动了一个新项目，可能是因为我之前做过物流相关的项目，而这个也是物流相关，所以领导决定让我去做，其实项目挺简单，所以从我接下来到现在，一年时间平平淡淡，项目稳步迭代，也没有什么大的技术难点，这让我中间有了一段时间的空闲期，中间抽身到别的项目去做过一段辅助性工作，再然后还是没需求进来，工作不饱和，我就开始思考起干脆去看点新东西吧。\n学习\nFlutter\n其实flutter这个跨平台框架发布已经有几年时间了，不过由于我没有认真去了解过，所以对于我来说是一个新的东西，以前看过几天，没有实际应用边学边忘，为了避免再次出现这样的情况于是我把公司的项目给仿写了下，\n当时找了好多在线教程教程和书籍包括《Flutter实战》以及在京东读书看的《Flutter入门与实战》\n一开始确实不太习惯，从命令式布局的UIKit到声明式布局的Flutter，当时在写的时候脑海中不自觉地问了很多次为什么，这里为什么要这么写，那里为什么要这么设计，因为当时我的思维逻辑还是iOS里UIKit的布局方式那一套，特别是写列表的时候，查了很多次Flutter的列表复用的问题，再比如…这嵌套也太tm恶心了吧🤮，为什么非要一层一层嵌套，我就写个层叠布局为什么非要套一层…之类的问题很多，但是写的久了之后，写的顺手了后，我只想说一句\n\n大概断断续续看了一个月左右，把现在项目大体给仿写了一遍，就此，搬砖技能+1\n在flutter看的基本能写项目后，本想在项目中应用下来写业务，但是调研了以native为基础的混合开发后发现，坑挺多的，业务闭环问题，路由问题，内存问题，包大小等等，和领导沟通后还是还是求稳为主，没有在项目中使用，但是那个仿写项目我还在继续。\nVue\n大概在三四个月前，项目组有个需求比较重要且紧急，当时的前端同事在做了排期后提出时间可能有点紧，而我当时手头刚好没需求在开发，领导就找到我说要不也参与进来做一些辅助性工作（其实我们公司前端人数挺多的，但是分散在各个项目组，而我们项目组刚好这时资源不太够），听完后我心里一想，可以啊，反正我之前也看过jQuery，有一点点基础，而我自己也有兴趣，于是便参与了进去\n公司前端项目用的是vue2.0，又是一波，文档，资料，看了后感觉，vue入门确实简单，很多东西都是现成的，直接用就好了，UI组件vant类似的库也是开箱即用，不像iOS，除了基本的组件什么都要自己搞，路由要自己搞，数据管理还复杂，就这么搞了大概两周，项目顺利上线，就此，搬砖技能+0.5（因为flutter起码我已经可以完整的写简单的项目了，而前端我只参与了其中的一个模块，不懂的东西茫茫多）\nvue的学习必须要感谢一位不愿意透漏姓名的老哥，感谢老哥的无私帮助，感谢命运让我们相遇，感谢党和政府给予我们的幸福生活😂😂😂\n英语\n啊，说起英语，学生时代就让我头痛，没想到毕业后还是要整天接触（真的是没想到，因为我非科班出身，毕业后在对口行业工作了半年后才参加培训转行开发）不过仅仅是开发的话其实对英语要求不高，想要进阶要求才高，毕竟很多文档，资料都是英文的.\n我大概是在前一段时间，在YouTube看视频，看到下边评论，大多数都是英文评论，而我又想知道他们到底说的什么（我知道YouTube自带翻译），我开始尝试着去理解评论，发现只能看个大概，很多单词不认识，所以又萌生了去学英语的想法，我为什么要说又呢？因为之前几乎每年都有这样的想法，但是都没有实际行动，于是我上某乎搜索，学英语app，然后把推荐的七八款app全都下载，一个一个打开看哪个更好用（好看），最终选择了其中的四款，但其实是两家公司的产品，这里我不得不吐槽下，为什么现在都喜欢把一个需求的子需求单独做app，然后开不同的会员，对不同的会员，比如听力，一个app，单词，又一个app，文章阅读再搞一个app，然后每个app都有单独的会员，我屮艸芔茻，产品经理鬼才啊是吧，逮着羊毛使劲薅是吧…\n但是吐槽归吐槽，该学还是要学，从基本的卖火柴的小女孩，阿拉丁神灯这些文章开始看起，每天再背点单词，到现在持续了差不多十天了，也不知道还能坚持几天，会不会像以前一样最后不了了之，总之先就这样吧，起码我目前没有放弃的想法…\n其他无关的书籍\n\n\n中间想填充下空虚的精神还看了几本杂书，因为以前很喜欢看雍正王朝电视剧，所以去看完了原著小说，雍正皇帝三部曲《九王夺嫡》《雕弓天狼》《恨水东逝》不得不说，电视拍的好，小说写得也棒；\n\n\n另外今年微博爆出的几篇小作文，把男女性别矛盾推向了新的高峰，我一直觉得性别之上还有人性，我们应该骂的是恶人，而不是性别不同的人，恶人自有法律制裁，而你，只需要做好自己，所以我想知道微博女拳到底在想什么，所以我去看了《女性主义有什么用》希望能了解一二，不过暂时还没看完；\n\n\n而我本人一直很喜欢看历史和自然相关的内容，以前在家整天看中央十套的《探索发现》《科技之光》《动物世界》之类的节目，书籍以前也看过一些，有一天突然在网上看到有人推荐《人类简史：从动物到上帝》，于是便找出来看了下，确实不错，虽然不讲具体的历史事件，但是会从历史进程去思考，更像是一本哲学书籍，目前也没看完，看了一部分，后续会接着继续看；\n\n\n生活\n今年，和谈了几年的女朋友也到了谈婚论嫁的地步，女朋友也来到了我工作的城市，围绕着订婚，三金，彩礼，车子等问题我们进行了坦率的沟通，充分交换了意见，进一步增进了双方的了解，顺利的订了婚。\n这期间，我们也闹过矛盾，大多是因为一些很小的，很细微的问题，甚至是一个眼神，一个手势，这让我倍感无奈，有时候对于一件事，明明有性价比更高，更合理简单的处理方式，但是却不去选择更优解，这让我难以理解，而我，只能在一声叹气后走过去，抱住，安慰两句，静静的等情绪的平复，有时候会更严重些，一直闹到半夜，虽然最后我们都会和好如初，但是我还是想说一句，人生啊…\n展望2022\n虽然是一个这么2的年份，我也有些许期待和计划…\n\n\n据传003要下水，期待满满，不知道有没有机会近距离去看看\n\n\n继续我的英语学习计划\n\n\n继续学习跨端以及前端技术\n\n\n使用flutter开发一个商业级项目\n\n\n看完五本书（太多怕打脸）\n\n\n开始定期写文，以前也写但是随缘，可能半年一年才写一篇\n\n\n体重重回62公斤\n\n\n挣更多的小钱钱（这是最主要的）\n\n\n中个500万吧不用太多😂\n\n\n结语\n最后，祝愿世界和平，祖国繁荣昌盛，疫情早日结束，各位事业进步，生活美满，风会指引你们前进的方向，大地母亲与你同在,Lok’Tar Ogar!!!🙏🙏🙏\n","categories":["随笔"],"tags":["年终总结"]},{"title":"SDWebImage链接重定向问题处理","url":"/posts/7f6c5879/","content":"Round 1\n最近公司的文件服务器进行了改造，即使是图片的加载请求也要携带token，否则无法加载，而我们项目中图片加载用的是SDWebImage,当时听到这个需求我内心毫无波动，心里已经…你懂得，不过该做还是要做，三下五除二写完了代码如下：\n[[SDWebImageDownloader sharedDownloader] setValue:@&quot;你的token&quot; forHTTPHeaderField:@&quot;Authorization&quot;];\nSDWebImage的下载处理是由SDWebImageDownloader单例类实现，所以在你项目中合适的地方加上这句代码，项目中所有用SDWebImage做图片加载的地方就都会携带上token了\nRound 2\n这样修改完后确实本来不能加载的地方变得正常了，直到那一天，那是一个春天…\n项目中要添加一个需求，需要引用公司的一个私有Pod功能库，又是一顿操作，集成完毕，逻辑编写完成，run，诶，图片居然没加载出来，我草这什么情况，我再次确认了一下，我的token设置完成了的\n我去询问编写这个Pod的同事，是不是我哪里没配置完成，他略微沉思一下两秒钟后说，你添加完token还要在SDWebImageDownloader修改下源码，我：？？？，随后他找到了这个源码，代码如下：\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler &#123;    // Identify the operation that runs this task and pass it the delegate method    NSOperation&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [self operationWithTask:task];    if ([dataOperation respondsToSelector:@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)]) &#123;        [dataOperation URLSession:session task:task willPerformHTTPRedirection:response newRequest:request completionHandler:completionHandler];    &#125; else &#123;        if (completionHandler) &#123;            completionHandler(request);        &#125;    &#125;&#125;\n他解释说道，这个功能模块里的一些图片链接中携带了一些参数，并不是直接指向资源，所以请求会进行重定向，所以需要在这里进行处理，处理后的代码如下：\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler &#123;        // Identify the operation that runs this task and pass it the delegate method    NSOperation&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [self operationWithTask:task];    NSMutableURLRequest *customRequest = [[NSMutableURLRequest alloc] initWithURL:request.URL];    customRequest.allHTTPHeaderFields = self.HTTPHeaders;    if ([dataOperation respondsToSelector:@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)]) &#123;        [dataOperation URLSession:session task:task willPerformHTTPRedirection:response newRequest:customRequest completionHandler:completionHandler];    &#125; else &#123;        if (completionHandler) &#123;            completionHandler(customRequest);        &#125;    &#125;&#125;\n我将代码修改后，run，确实，问题解决了，但是不对啊，我们的SDWebImage是通过Pod的方式集成的，这样直接在Pod文件夹下修改三方的源码，那么下次更新后，岂不是被覆盖了？这是一个新的问题，于是我开始思考怎么解决重定向问题的同事不修改三方库的源码，脑海中瞬间就想到了AOP\niOS开发中优秀的AOP库那必须有Aspects名字，接下来我开始思考具体步骤\n首先，通过同事提供的解决问题的代码来看，他是把参数request给改为了一个自定义的customRequest，这两个的区别，然后重新设置了allHTTPHeaderFields\nNSMutableURLRequest *customRequest = [[NSMutableURLRequest alloc] initWithURL:request.URL];customRequest.allHTTPHeaderFields = self.HTTPHeaders;\n那么我想，问题主要就是在allHTTPHeaderFields这里了，我打印了request和customRequest的allHTTPHeaderFields后发现，前者比后者少了token,怪不得无法加载，这里要提一下下边这个方法\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler \n这其实不是SDWebImageDownloader的方法，是NSURLSessionTaskDelegate的里的协议方法，SDWebImageDownloader实现协议方法后在里边做了自己的重定向处理\n那么说一下我一开始的想法，既然问题出在重定向时request里未携带我们手动添加的token，并且重定向这里肯定是要做处理的，那我们直接把相关参数设置给request，没必要创建一个新的customRequest实例\n[request setValue:self.HTTPHeaders forKey:@&quot;allHTTPHeaderFields&quot;];\n因为request是一个NSURLRequest对象，它的allHTTPHeaderFields是一个readonly属性，我们不能直接修改，所以我想当然的用KVC去操作，\n然后 run ，然后 我草crash了，报错信息如下\n&quot;[&lt;NSURLRequest 0x2800efa50&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key allHTTPHeaderFields.&quot;\n看描述信息是说NSURLRequest没有对应的allHTTPHeaderFields这个key，有那么一瞬间我愣了下，这不科学啊怎么可能没有，我点进NSURLRequest类确认了下，有啊，什么情况，但是本着求知的态度，我心想是不是NSURLRequest内部使用的是不是不叫allHTTPHeaderFields,但是不对啊，这个属性明明在的啊，即使是别的也应该是内部重新赋值我这里不应该报错啊，不过我还是用通过runtime将他的属性列表打印了一下，再次确认了，他确实有allHTTPHeaderFields这个属性，于是我搜索了下相关问题，发现了一个关键词\n+ (BOOL)accessInstanceVariablesDirectly\n详细信息自行检索，我这里说下结果，这个是针对KVC的，总的来说，当一个类实现了这个方法并且返回了YES他就可以通过KVC(这个说法不完全准确，因为本文不是针对KVC的故简要说明)赋值，如果返回NO就不可以用KVC赋值\n看到这里后我猜测NSURLRequest里这个方法应该是返回了NO,那完了，走不通了，还是要实例化一个新的对象\nRound 3\n搞了半天想省事看来不行啊，那拉倒，直接开始AOP修改：\nNSError * error ;[[SDWebImageDownloader sharedDownloader] aspect_hookSelector:@selector(URLSession: task: willPerformHTTPRedirection: newRequest: completionHandler:) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, NSString *num)&#123;        NSArray * param = aspectInfo.arguments;    NSURLRequest * request = param[3];    NSURLSessionTask * task = param[1];    NSMutableURLRequest *customRequest = [[NSMutableURLRequest alloc] initWithURL:request.URL];    customRequest.allHTTPHeaderFields = task.currentRequest.allHTTPHeaderFields;    request = customRequest;    NSInvocation * invocation = aspectInfo.originalInvocation;    [invocation setArgument:&amp;request atIndex:5];    [invocation invoke];    &#125; error:&amp;error];\n这里边aspectInfo就是被hook方法的信息，可以通过它取到原方法的参数，调用对象等等，我们这里要添加我们的token，因此取出参数进行修改\n\narguments是原方法的入参列表，是一个数组\ninvocation是一个消息对象，包含了一个方法的所有信息\n通过URLSession: task: willPerformHTTPRedirection: newRequest: completionHandler:方法我们可以知道request的索引是3，task的索引是1（取出它是因为我们要获取原header信息，这个不能丢弃），之后对request重新进行赋值，完成修改，然后重新调用方法\n\n[invocation setArgument:&amp;request atIndex:5];[invocation invoke];\n因为我们只需要修改request一个对象，因此只重新设置这一个方法入参，至于这里为什么在赋值的时候索引是5,因为前两个分别被该方法的self与_cmd占用，所以我们设置参数的时候索引是从2开始\n再次run，嗯，图片顺利加载，问题解决。\n这样一来，我们就不需要修改三方的源码就解决了问题，否则修改源码的话每次更新Pod我们的修改就会被覆盖掉，如果哪次发版没注意，测试也没回归覆盖，很容易将问题带到线上\n","categories":["开发"],"tags":["iOS"]},{"title":"利用汇编挖掘编程语言本质","url":"/posts/2102ad03/","content":"Get\n1. 汇编代码和二进制代码一一对应，\n\n每一句汇编代码和二进制代码一一对应，所以二进制代码可以反汇编出汇编代码（伪代码，不一定百分之百准确），\n汇编代码根据平台不同会有所不同，x86,armv7,arm64等，由于不同平台会有不同的指令集，所以同样的高级语言编译出来的汇编代码可能会不同，但是大同小异\n\n2. ifelse和switch的效率\n\n通过汇编可发现，某些情况下，switch效率会比ifelse高（case比较多，且相互之间差值不大，如果差值非常大会用类似ifelse的处理方式），因为ifelse会执行每一个情况的判断代码，不符合则跳转下一个，最终执行完所有的ifelse，\nswitch则会通过一定算法，直接算出结果，然后跳转到相应的语句的内存地址\n\n3. 函数的内存分布\n\n函数的调用会开辟栈空间，栈空间会有指针（esp，平台不同名称可能不同）标识栈顶的位置\n每次压栈都会更新栈顶，函数栈空间会存储局部变量等，每次函数执行完成，esp都会回到调用函数前的位置，这叫做栈平衡，防止栈溢出\n因为每次调用函数都会开辟栈空间，esp都会移动到栈顶，所以递归函数如果没有退出条件，esp会一直移动，直到栈空间不足，栈溢出程序报错\nesp只是标识栈顶的位置，所标记内存地址之下（更小的地址）被视为未使用内存，可以分配给新的函数或变量使用，但其实每次使用后，内存中存储的数据还在，只是被标记为未使用，下次使用可以直接覆盖内容\n\n","categories":["开发"],"tags":["汇编","重学开发"]},{"title":"疫情于我","url":"/posts/6a6dcc9e/","content":"受疫情影响，截止到今天，我已经居家办公59天，足不出户封闭52天，这将近两个月的是将，我的心态不断变化，甚至可能影响以后的我。\n天真\n其实在我没有开始居家办公的时候，疫情已经小规模扩散开了，我记得通知居家办公前几天，我们公司还有一位同事不幸确诊，当时我们也是人心惶惶，心里边多少有点害怕，不过因为不在同一个楼层，并且在他确诊前后也没有来过我们楼层，所以虽然害怕，但是也相信政府和公司，并没有太多担心。\n在真正通知居家办公时，只有浦东，徐汇等区比较严重，我所在的区还好，起码那几天出门，交通都没有限制，不过按照当时的趋势，我也明白我们封闭也只是时间问题，所以那几天我就尽量每天出门买菜，说实话，那几天买菜明显感觉到菜价比平时贵了许多，娃娃菜，生菜等常吃的都涨到了七八块，青椒将近十块，而本来已经降价的猪肉也重新涨到了20+，但是即使贵也要买，心想就这一段，过去了就好了，但后来铺天盖地的负面事实证明，我太天真了。\n食物\n大概是三月底二十七八号左右吧，正式通知要足不出户居家隔离，以黄浦江为界，浦西开始时间从四月一号开始，到四月五号，我就在浦西，当时我是真的相信到四月五号会结束封闭，我还劝我女朋友，魔都毕竟是魔都，不用太过担心，这时候其实我储备了大约一周的食物，都是提前买的，包括菜油大米之类的，但事实证明我确实对上海抱有了过分的信心。\n第一天小区还发了物资，我之前就听说上海政府会在隔离期间发放物资，但是我收到的第一次物资实在是一言难尽，当时我就想，除非实在没有吃的，否则绝不动用这次的物资，\n\n四月五号，并没有解封，但这时候，菜市场已经关闭，美团买菜，盒马，叮咚买菜也都被关闭，我终于意识到，网上流传的，在家没有吃的等死的事情，真的会发生，后续的事情大家也都知道，各个区都开始有倒卖物资，高价团购，以物易物等，后续又发放了四五次物资，都很不错，我也很感谢社区，感谢伸出援手的企业\n整体来看，直到现在，疫情在家两个月，虽然瘦了十斤左右，但是在有团购和物资的情况下，我并没有感觉自己被饿到。\n医疗\n这还不止，吃只是一方面，要知道疫情下社会停摆的影响是巨大的，医疗资源挤兑严重，大部分的医疗资源都被调去优先处理解决疫情，那么其他患者获得的医疗资源就会减少，甚至是没有，果然，没过几天，网上开始爆出各种，化疗无法就医，孕妇无法就医，其他病症就医因不能出具有效核酸证明而被拒之门外导致耽误最佳治疗时间，加重了病情甚至死亡，著名经济学家郎咸平的母亲也收到了影响，真的是应了那句话，时代的一粒灰，落在一个家庭，一个人身上就是一座山。\n为了尽快结束疫情，核酸检测一次接一次，但中间有个插曲让我觉得无法理解，我们楼上有邻居确诊被拉去方舱，可是作为同一栋楼的我们，居然在三天后才知道这件事，这中间我们还每天下楼丢垃圾，知道这件事情后我们非常气愤，询问为什么居委不告知我们?同一栋楼的我们不更应该知道，然后做好防护措施吗？而这时候的居委就像消失了一样，群里@也毫无反应，不过还好，最后大家都没事，但是你以为就这么结束了吗？并没有。\n自从楼栋出现确诊后，本来几天做一次的核酸检测也停了，注意停的只是我们，到了检测日期，其他楼栋都是正常检测， 唯独将我们楼忽略了，询问居委，得到的回答是，大白从上午工作到下午两三点累了，改天再做。我？？？，我们50号楼，旁边的49号，51号都做了我们就在他们中间没有做是因为大白累了？？？这时候我们其实根本不相信他的说辞，大家都开始猜测，是不是因为楼上有确诊，害怕我们也有感染处于潜伏期，下楼做核酸再感染其他人，但是这种情况的我们不是更应该做检测？如果不能下楼去做，检测最后大白上门做总可以吧？既然检测力度这么大，甚至将其他的医疗资源都优先用于新冠疫情，做到这点不是更应该？总之这件事让我无法理解。\n这中间有件事也让我彻底吓坏了，但是又只能强作镇定，我女朋友突然发烧了，最高到38.4，明明中午吃饭时候还好好的没问题，下午三点钟就开始觉得不舒服，量了下体温37.6，我让她吃了点社区发放的连花清瘟，因为家里没有其他的退烧药，只有这个写的有退烧功效，但事实证明并没有什么卵用，吃过药后过了一个半小时再次量体温，烧的更严重了，我开始在群里询问哪位邻居家有药，很幸运邻居们都很有爱，纷纷说自己家里有你可以过来拿，于是我去了最先回答的那位邻居家，他们给的是布洛芬，不过是小孩子吃的那种，但据他说他之前吃过有效，回去立马让我女朋友吃了点后让他睡下，到了奖金八点，再次量体温，降下来了点，但是仍然在37度多点，这时候我看距离上次吃药已经过了将近四个小时，于是又让她吃了点睡下。\n第二天早上起床后就立马量体温，还是37度，不过我已经不像昨晚那么担心了，后续又发生了很多事，有其他邻居给了头孢，居委打电话询问病情，本计划的全员核酸也不让我们去做了，最后还是以为热心的大白上门给我女朋友做了核酸，她在前一天还送了退烧贴给我们，我真的很感谢她，后来本以为没事了，谁想到提问重新升到了38左右，这时候我是真的有点恐慌了，但是如果我表现的很明显的话只会让情况更糟，所以只能故作镇定，我开始联系大白和居委如何才能去医院，而邻居也开始不断的说让我们去医院，我明白，这时候发烧，不是一个人的事情，其实邻居们也还怕，但是我没想到我女朋友会抗拒，好说歹说就是不愿去医院，我很无奈甚至有点生气，在外邻居们在非议，当然他们也是出于好心我并不怪罪他们，反而感谢他们伸出援手，在内还要被女朋友怪罪说把病情发在群里，说实话我那时候确实有点生气，但是忍了下来，我说到中午，如果体温还起伏的话，别再说别的，去医院，这次他终于答应，很幸运，中午的体温正常了，后边每隔一个小时都量一次体温，直到晚上都没有异常，此时我悬着的心终于放了下来，哎。\n工作\n由于工作性质的原因，虽然居家办公，但其实对工作效率的影响并不大，依然是每天晨会沟通工作计划，视频会议沟通各种需求，技术方案，随后开发，测试等等。一切有条不紊的推进。\n但是大概在居家二十多天，将近一个月后，我开始变得有点烦躁，开始怀念去公司上班的日子，因为我发现居家办公久了之后，很容易被其他事情分散注意力，很难专注在工作上，对于不太复杂的任务还好，相对复杂一点的任务这种状态是不可取的，我询问了朋友和同事，发现他们都有这种感受，我不知道这是错觉，还是因为隔离久了后情绪发生的莫名的变化\n学习\n有更多的在家时间，也意味着有更多的时间可以放在工作之外，比如游戏，音乐，社交软件等等，但是同样在一段时间后，突然有那么些瞬间，觉得这些都无关紧要，也可能是因为每天都吃自己爱吃的菜同样会腻的原因；这中间的一天我无意中打开脉脉，突然认识到一件事，疫情导致社会的停摆，怎么可能只影响到吃喝与医疗？看看脉脉不断有人哀叹失业，哀叹工作难找就明白了，疫情的影响是方方面面的！\n我终于开始关注之前被我不自觉忽略的新闻，就业形势，大厂裁员，季度GDP大幅下降，这让我恐慌，恐慌情绪支配下的我，对于什么游戏，社交，更加失去兴趣，我开始想，我如果被毕业了怎么办，我如果被社会淘汰了怎么办？我的房租，房贷，吃穿用度怎么办？这让我非常焦虑，好几个夜晚，躺在床上都在想这些事情，特别是看到我那小傻瓜一样的女朋友每天就是看看韩剧，看看综艺，刷刷微博，看看吃播我就更无语，我心想，你难道从来不担心这些的吗？万一我失业了交不起房租，我们住哪？万一将来找不到工作，房贷逾期怎么办？\n连续几天我被这种焦虑情绪支配，我知道我不能一直这样，我开始想办法摆脱这种困境，于是我开始看书，开始看技术文章，开始学习，其实我一直有在学习，但之前的纯属于兴趣使然，从没有像这样担心将来到焦虑，逼着自己去学习。\n连续一周不停的学习，白天有空就看文章，晚上吃了饭就开始敲代码验证想法，甚至关了灯躺在床上还在想，这么问题怎么解决？事后来看，那几天的我简直魔怔了，魔怔到有点好笑，虽然现在我学习的强度比前一段有所下降，但是依然保持每天学习从不拉下，而就这么持续了一二十天后，我发现这中间我完全没想起来去玩游戏，是真的没想起来，就想他们本身就不存在一样，而这种状态下得我感到了一种格外的充实和安全感。\n而这中间我也认识到了很多的不足，所以暂时有个想法，我想重新开始学习开发，从那些最基础的，最简单的东西开始，把自己当成一个初出校门的小白，重新认识自己这个行业。\n再后来，我不满足于看电子书，看技术文章，看源码，看视频，我翻出了吃灰许久的实体书籍，开始得空就在阳台坐着翻看，安静的傍晚，或是夜幕降临后，坐在沙发上，一个人看着书，偶尔抬头望向我那小傻子一样又在看不知道什么综艺的女朋友，我觉得，可能现在的我想太多只会让自己变得更加沮丧，在疫情下无法出门，社会停摆，无论什么想太多都是一种负担，不如趁这段时间提升自己，不是有那句话吗，你若盛开，蝴蝶自来。\n最后\n啰嗦了这么多，都不知道自己在说些什么了，在家这两个月还发生了许多事情，有好的，有坏的，很多都没有在这里写出来，有关于个人的，有关于这座城市的，但是这两个月下来我的心态确实发生了变化，对工作，对生活，对学习，或许这种心态会影响我一生，或许是一阵，这知道呢，不过我清楚的是，无论影响多久，这都是我，我走过的路，我经历过的好的，坏的，所有事情，构成了现在的我，用一句话来说就是，我与我周旋久，宁做我。\n","categories":["随笔"],"tags":["疫情"]}]