<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lazyloading的博客</title>
  
  <subtitle>我与我周旋久，宁做我。</subtitle>
  <link href="https://lazy.wiki/atom.xml" rel="self"/>
  
  <link href="https://lazy.wiki/"/>
  <updated>2022-06-03T02:52:14.235Z</updated>
  <id>https://lazy.wiki/</id>
  
  <author>
    <name>Lazyloading</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue自定义指令</title>
    <link href="https://lazy.wiki/posts/8833154b/"/>
    <id>https://lazy.wiki/posts/8833154b/</id>
    <published>2022-06-03T02:23:37.000Z</published>
    <updated>2022-06-03T02:52:14.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>前两个月因为公司工作内容调整，我这边开始负责一个前端项目，其实去年三季度时候这个项目有个需求排期比较紧张，boss又不想去其他项目组借人，而我当时手上iOS迭代刚好完成，于是我就提出可以参与进来，领导同意后就让我进来参与了一个模块的开发；今年这次调整算是彻底把这个项目交到我手上了，不过要说明的一点是我主要还是要做iOS的&gt;_&lt;，无论我参与前端还是后端，最终我都是一个iOSer😂😂😂</p><h3 id="正文">正文</h3><p>因为我前端开发经验不足，说白了就是前端菜鸟，只不过之前由于兴趣看了学了些前端知识，又由于某些机会参与了一些项目，慢慢的也开始负责前端项目，但是经验还是不足。</p><p>这不，最近在开发过程中，有一个很小的功能，就是防止用户连点按钮，导致多次发起请求，我一开始的想法是点击的时候，做个判断，变量保存状态值，也确实这么去实现了，但是感觉这样写的话每个按钮都要写一遍，所以就搜了下有没有其他处理放水，然后就看到了一个自定义指令实现的方案</p><p>关于自定义指令的介绍看<a class="link"   href="https://cn.vuejs.org/v2/guide/custom-directive.html" >官方文档<i class="fas fa-external-link-alt"></i></a>，其实我们在使用Vue时常用的绑定乳<code>model</code>，<code>show</code>等都是内置的一些指令，我们也可以自己写一些指令实现一些特殊的操作，比如我这个需求可以这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;doubleClick&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">      el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!el.<span class="property">disabled</span>) &#123;</span><br><span class="line">              el.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">              <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  el.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">              &#125;, binding.<span class="property">value</span> || <span class="number">1500</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我因为想要全局都可以使用，所以直接在<code>main.js</code>中去注册了这个指令，那么在使用的时候就是如下方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line">    &lt;div</span><br><span class="line">        <span class="keyword">class</span>=<span class="string">&quot;license_text_action&quot;</span></span><br><span class="line">        @click=<span class="string">&quot;download(item.fileUrl, item.fileName)&quot;</span></span><br><span class="line">        v-doubleClick=<span class="string">&quot;2000&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">class</span>=<span class="string">&quot;license_text_action&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        @<span class="attr">click</span>=<span class="string">&quot;download(item.fileUrl, item.fileName)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">v-doubleClick</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br></pre></td></tr></table></figure><p>这样就可以实现防止快速连续点击，时间可以自定义单位毫秒，详细使用和相关参数解释可以查看<a class="link"   href="https://cn.vuejs.org/v2/guide/custom-directive.html" >官方文档<i class="fas fa-external-link-alt"></i></a>,我就不直接贴文档内容了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;前两个月因为公司工作内容调整，我这边开始负责一个前端项目，其实去年三季度时候这个项目有个需求排期比较紧张，boss又不想去其他项目组借人，而我当时手上iOS迭代刚好完成，于是我就提出可以参与进来，领导同意后就让我进来参与了一个模块的开</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="前端" scheme="https://lazy.wiki/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://lazy.wiki/tags/Vue/"/>
    
    <category term="指令" scheme="https://lazy.wiki/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>网络(3)--子网,超网</title>
    <link href="https://lazy.wiki/posts/bdfeed9c/"/>
    <id>https://lazy.wiki/posts/bdfeed9c/</id>
    <published>2022-05-28T15:33:27.000Z</published>
    <updated>2022-05-28T16:03:26.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子网">子网</h2><h3 id="目的">目的</h3><p>那么通过上一篇IP地址的分类，网段的计算，各网段可容纳的主机数量这些内容我们可以知道平时我们用的IP地址都属于C类地址，</p><p>如果我们有240台设备要让它们在同一个网段的话可以分配一个C类网段，这样基本可以做到资源充分利用，那如果我们有300台设备该怎么办？一个C类网段显然不够用</p><p>但是如果分配一个B类网段，通过前文我们知道一个B类网段可以容纳<strong>65534</strong>台设备，可以分配的范围举例是从<code>191.100.0.1</code>到<code>191.100.255.254</code>而我们其实只有300台设备，这样显然空闲了65000+多个IP，造成资源浪费。</p><p>这时候我们其实可以进行子网划分，将一个网段划分成多个子网段，每个子网段可以容纳不同数量的设备，核心就是<strong>网段部分不变，借用主机位来划分出多个子网</strong></p><p>那什么是借用主机位？举个例子<code>192.168.3.1/24</code>这个地址是个C类地址，那么主机位其实就是第4个字节也就是最后一部分<code>1</code>,那这部分其实有8位二进制数，借用主机位的意思就是从这本来表示主机的8位二进制中取出几位来表示网段，我们用图片表示来理解下<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205271045884.png"                      alt="图片来源于网络"                ><br>绿色部分就表示从主机位借用的部分</p><h3 id="原理">原理</h3><p>子网划分就是将一个网段分成多个子网段，每个子网段可用IP数量都是划分前的二分之一<br>举例我们有120台主机要在一个网段，有另外120台主机要在另一个网段，那这时候我们如果分配AB类地址显然不合适，只有C类地址合适，C类地址一个网段可以容纳254台主机，分成两部分的话一部分就是127，刚好可以满足我们的需求，并且多出的几个也不会显得很浪费，看下图表示</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205271133162.webp"                      alt=""                ><br>以这个图为例，现在有一个C类网段192.168.0.0/24，那么他的主机范围就是从<code>192.168.0.1</code>到<code>192.168.0.254</code><br>那么从主机位借一位的话就要将子网掩码往后移一位(这里指的是2进制位)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从</span><br><span class="line">1111 1111.1111 1111.1111 1111.0000 0000</span><br><span class="line">255.255.255.0</span><br><span class="line">变为</span><br><span class="line">1111 1111.1111 1111.1111 1111.1000 0000</span><br><span class="line">255.255.255.128</span><br></pre></td></tr></table></figure><p>那这样借了一位后，网络部分就变成了<strong>25</strong>位，主机位变成了<strong>7</strong>位，同时也产生了两个新的网段，因为子网掩码后移一位后，IP地址的第25位<code>&amp;</code>上这个1就会有0和1两种状态，那也就代表两个网段</p><ul><li>如果第25位是0，0<code>&amp;</code>子网掩码第25位那个1结果就是0，那么这个网段就是<code>192.168.0.0/25</code>，我们就叫他A子网段，那么他的主机位范围就是<code>192.168.0.1~192.168.0.126</code>，因为主机位用2进制表示全0（十进制0）的话代表这是一个网段，全1（十进制127）代表这是个广播地址，这些概念我们在前两篇讲过</li><li>如果第25位是1，1<code>&amp;</code>子网掩码第25位那个1结果就是1，那么这个网段就是<code>192.168.0.128/25</code>，我们就叫他B子网段，同样的道理他的主机位范围就是<code>192.168.0.129~192.168.0.254</code></li></ul><p>那么上边的等分两个子网的看过后我们再来巩固下，看等分四个子网的情况<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205271133140.webp"                      alt=""                ></p><p>图中已经标注的很详细了，结合等分两个子网的情况对照下看</p><h3 id="总结">总结</h3><p>所以子网划分记住</p><ul><li>子网掩码右移n位，可以将原网段划分成2^n个子网</li></ul><h2 id="超网">超网</h2><p>此时，我们再思考一个问题，刚才的实现是让120台主机在一个网段，等分出两个子网，那如果现在有400台主机要在一个网段呢？</p><p>首先子网划分当然可以做到这一点，但是一个能容纳400台主机的B类网段可以容纳6w+台设备，我们如果通过上面的方式，要划分很多次才能实现，这样显然比较麻烦，现在我们可以通过超网的方式更简单的实现这个需求，超网可将多个连续的同类网段联合在一起<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205271856184.png"                      alt=""                ></p><p>就以上图为例，举例有200台设备在A<code>192.168.0.0/24</code>这个网段，有另外200台设备在B<code>192.168.1.0/24</code>这个网段</p><p>现在我们要让这400台设备在同一个网段可以这么做，我们将子网掩码左移一位变成23位，那么子网掩码变成23位后，就表示AB两个网段也由他们的前23位确定，第24位变成了主机位，那么整个主机位部分就变成了9位而不是8位，那么变成9位后，他的取值范围就变成了<code>0 0000 0000~1 1111 1111</code>转化成十进制就是<code>0~511</code>，这个网段的范围就是<code>192.168.0.1~192.168.1.254</code>,那么可容纳的主机也就变成了500+台</p><p>而这个合并后的网段就是192.168.0.0/23,因为网段的表示就是除了网络位，主机位全是0</p><p>那么我们来思考一个问题，<code>192.168.0.255/23</code>这个IP可以分配给主机吗？<br>首先我们想一下一个网段内分配IP时有两个IP不能用</p><ul><li>主机位全0不能用，它表示网段</li><li>主机位全1不能用，它表示广播</li></ul><p>这两个概念前文有说过，那么这个IP的第4部分主机位的8位全为1，那它是个广播地址吗？不是的，因为现在它的主机位是9位，这一位在第3部分，并且是0，那么它的主机位既不是全0，也不是全1，所以可以分配给主机使用<br>如果它是<code>192.168.1.255/23</code>,这样就不能分配给主机，因为它的主机位9位全为1，所以这是一个广播地址</p><p>那再看一个图<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205282239826.png"                      alt=""                ><br>相信可以猜得到，这个其实就是4个网段合并的图例，将主机位左移2位，子网掩码变成了22位，主机位变成了10位，那么合并后的网段可以容纳的主机约就是4个网段的和，合并后的网段就是<code>192.168.0.0/22</code>，主机位范围就是<code>192.168.0.1~192.168.3.254</code></p><p>那这么一看，合并网段也很简单，真的是这样吗？继续看下图<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205282247037.png"                      alt=""                ><br>图上这两个网段A<code>192.168.1.0/24</code>和B<code>192.168.2.0/24</code>能合并吗？我们来分析下</p><ul><li>A网段主机位左移一位后，子网掩码变成23位，主机位变成了9位，网络位变成了23位，那么他的网段表示是什么，就是主机位9位全0，就是<code>192.168.0.0/23</code></li><li>B网段主机位左移一位后，子网掩码变成23位，主机位变成了9位，网络位变成了23位，但是它的第3部分第7位是1，所以即使他的主机为9位全为0，网段表示也是<code>192.168.2.0/23</code></li></ul><p>那么左移后AB的网段分别是<code>192.168.0.0/23</code>和<code>192.168.2.0/23</code>，显然不相等，所以他们不能合并</p><h3 id="总结-2">总结</h3><p>那么网段合并有什么规律呢？其实记住3条就可以了</p><ol><li>子网掩码左移n位，可以合并2^n个网段</li><li>要合并的网段必须是连续的</li><li>要合并的网段中，第一个网段的网络号能够被n整除</li></ol><p><a href="https://lazy.wiki/posts/4947d79c/">网络(2)–IP分类,网段确定</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子网&quot;&gt;子网&lt;/h2&gt;
&lt;h3 id=&quot;目的&quot;&gt;目的&lt;/h3&gt;
&lt;p&gt;那么通过上一篇IP地址的分类，网段的计算，各网段可容纳的主机数量这些内容我们可以知道平时我们用的IP地址都属于C类地址，&lt;/p&gt;
&lt;p&gt;如果我们有240台设备要让它们在同一个网段的话可以分配一个</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="重学开发" scheme="https://lazy.wiki/tags/%E9%87%8D%E5%AD%A6%E5%BC%80%E5%8F%91/"/>
    
    <category term="网络" scheme="https://lazy.wiki/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>GCD(1)--任务的顺序</title>
    <link href="https://lazy.wiki/posts/a3a7c4e/"/>
    <id>https://lazy.wiki/posts/a3a7c4e/</id>
    <published>2022-05-26T09:50:54.000Z</published>
    <updated>2022-05-28T15:57:39.500Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1>GCD（1）任务的顺序</h1><h3 id="前言">前言</h3><p>GCD这个东西老生常谈了，我们在开发中还是比较常用，几乎我们每个项目中都会用到,但是频率却又不是特别高（先别反驳）。</p><p>因为可能只是个别对操作有特殊要求的地方使用，所以导致很多人对GCD熟悉但是不熟练，你可能会说我们的网络请求，图片加载等都用到了GCD实现多线程啊，是的不错，不过这些都是框架比如afn，sd等给我们封装好了的，真正我们主动自己去封装GCD进行操作的地方并不是很多，包括我自己之前对其中的部分也不是特别明白，后面我会模拟一下我们常用的操作，来让我们正确通过GCD使用多线程。</p><h3 id="代码">代码</h3><p>国际惯例先看几个示例：</p><h4 id="示例1">示例1</h4><p>下面的代码打印顺序是什么样的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;lazy&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;4--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;5--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;6--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们先不着急给答案，先给答案可能会先入为主，影响理解，先来分析，看看答案可能是什么<br><strong>分析：</strong></p><ol><li><code>queue</code>是一个并发队列，任务12356都在这个队列，并发队列有多个任务出口，任务4在主队列，主队列是串行队列，只有一个任务出口</li><li><code>queue</code>中任务3是个同步任务，特点是不会开辟线程，且会立即执行任务并阻塞线程直到任务结束才执行下一个任务，1256是异步任务，可以开辟线程，不会立即执行会等待CPU调度，并且不会阻塞线程</li><li>通过前两步分析可知，<code>queue</code>中3不执行完，后续任务不会进入队列，那么56肯定在3之后入队列，而12入队列在3之前但是是异步任务，执行顺序不确定，所以12可能在3之前也可能在3之后，也可能3在12之间，那么其实1256整体之间的顺序就也不确定，4虽然不在<code>queue</code>中，但是3阻塞了主线程，所以4也在3之后</li><li>3结束后立马执行了4，56因为是异步任务顺序也不确定，但肯定在4之后</li></ol><p>经过上面的分析可以得出几个可能的答案，分别是：</p><ul><li>123456</li><li>324156</li><li>312465<br>…当然还有其他符合的答案，具体根据代码运行时CPU的状态决定，但都会符合上边4条分析的结论，下面我贴一下我这边打印出的几个结果</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>--&lt;_NSMainThread: <span class="number">0x600002ed0140</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e94280</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">4</span>--&lt;_NSMainThread: <span class="number">0x600002ed0140</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">1</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600002ed1e40</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">5</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600002ed1e40</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">6</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e94280</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">----------------------------分割线--------------------------------</span><br><span class="line"><span class="number">3</span>--&lt;_NSMainThread: <span class="number">0x600001250840</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001261c40</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">4</span>--&lt;_NSMainThread: <span class="number">0x600001250840</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">5</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001261c40</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">6</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001200040</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">1</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600001209ec0</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>你也可以亲自动手试一下</p><h4 id="示例2">示例2</h4><p>下面的代码打印顺序是什么样的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;lazy&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">     <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;4&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure><p>同样的我们先来分析，看看答案可能是什么</p><ol><li><code>queue</code>是一个并发队列，234是异步任务在这个队列中，15在主队列（上边重复过的内容省略）</li><li>1肯定先打印，其他任务都在它之后，之后24加入队列，因为这是一个异步任务所以会先入队列等待执行，之后打印5</li><li>而当异步任务块被执行时（注意这个执行时），打印了2之后，又有一个异步任务3，此时将任务3加入队列等待执行,然后继续执行4，所以34肯定在2之后</li><li>那么24这个异步任务块结束后会从队列中取出3执行，为什么会等24之后执行3呢？因为3是在24执行时加入队列的任务，它入队列时候已经在执行打印24了，而3还处于等待执行状态</li><li>最后打印出来就是15243</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--&lt;_NSMainThread: <span class="number">0x600003224140</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">5</span>--&lt;_NSMainThread: <span class="number">0x600003224140</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000327cb00</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">4</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000327cb00</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">3</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003262e00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>那么下面再稍微变一点点，再看打印的是什么</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;lazy&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>);</span><br><span class="line">     <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;4&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们来分析下</p><ol><li><code>queue</code>是一个并发队列，24是异步任务在<code>queue</code>中，3是同步任务在<code>queue</code>中，15在主队列（上边重复过的内容省略）</li><li>1肯定先打印，其他任务都在它之后，之后24加入队列，因为这是一个异步任务所以会先入队列等待执行，之后打印5</li><li>当异步任务块被执行打印了2之后，此时有一个同步任务3加入队列，那同步任务的特点是不开辟线程并阻塞线程立即执行，所以3会打印，然后继续执行4</li><li>最后打印出的结果就是15234</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--&lt;_NSMainThread: <span class="number">0x600003a2c7c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">5</span>--&lt;_NSMainThread: <span class="number">0x600003a2c7c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003a3c5c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">3</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003a3c5c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">4</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003a3c5c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例3">示例3</h4><p>下面的代码打印顺序是什么样的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;lazy&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;3--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;4--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;5--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure><p>可以看出，这个和上边的示例也很相似，我们先来分析下</p><ol><li><code>queue</code>在这里是串行队列，24是异步任务在<code>queue</code>中，3是同步任务在<code>queue</code>中，15在主队列（上边重复过的内容省略）</li><li>1肯定先打印，其他任务都在它之后，之后24加入队列，因为这是一个异步任务所以会先入队列等待执行，之后打印5</li><li>当异步任务块被<strong>执行时</strong>打印了2之后，此时有一个同步任务3加入队列，那同步任务的特点是不开辟线程并阻塞线程立即执行，可是<code>queue</code>是个串行队列只有一个出口也就是同一时间只能有一个任务在出队列，那么在24出了一半的时候，3要求立马出可是3在队列中处于24之后，就造成了拥挤等待，24执行完才能执行3，3要求立马执行，执行完才能执行4，互相等待就会crash</li><li>所以打印应该是152然后crash</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205261711212.png"                      alt=""                ><br>这种相互等待的情况就叫死锁，所以我们在使用串行队列，并且有同步任务的时候，一定要注意，在同步任务执行前，一定确保之前的任务都执行完了</p><h4 id="示例4">示例4</h4><p>那么看了上一个死锁导致crash的例子后我们再来看一个</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;lazy&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"><span class="comment">//        sleep(1);</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;4--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure><p>国际惯例先来分析</p><ol><li><code>queue</code>是个串行队列只有一个出口也就是同一时间只能有一个任务在出队列，后边的任务不能插队，23都在<code>queue</code>这个队列中，14在主队列（上边重复过的内容省略）</li><li>14都在主队列，1肯定先打印，234都在它后边，那4呢？4之前有个同步任务3，通过上边几个例子我们知道同步任务的特点，所以4肯定要等3执行完，那么4就在3之后，</li><li>再来看2，它虽然是一个异步任务，但是串行队列只有一个出口也就是同一时间只能有一个任务在出队列，先加入队列的任务即使不执行也会挡住出口，<code>queue</code>中3排在2之后，3要等待2执行完才能开始执行</li><li>那么这个例子和上边死锁的有什么区别？这例子中3虽然是同步任务但并不是在2<strong>执行时</strong>加入队列的，所以2执行时不需要考虑3的情况，也就不会造成相互等待，也就不会死锁</li><li>那么分析后最终应该是1234</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--&lt;_NSMainThread: <span class="number">0x600002538440</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x600002573d00</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">3</span>--&lt;_NSMainThread: <span class="number">0x600002538440</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">4</span>--&lt;_NSMainThread: <span class="number">0x600002538440</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>如果对于第3条分析里2这个异步任务的顺序有疑问，可以吧代码中2上边的注释<code>sleep(1)</code>打开，看是不是即使2睡了一秒后，3还是会在他之后</p><h4 id="示例5">示例5</h4><p>再来看最后一个，下面的代码循环外会打印什么？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block  <span class="built_in">NSInteger</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld--%@&quot;</span>,num,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;%ld--%@\n&quot;</span>,num,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure><p>同样的我们先来分析</p><ol><li>一个while循环，出循环的条件是num &gt;= 10，并且是在主队列主线程执行</li><li>循环里边会将一个异步任务加入全局队列，任务是将循环外的变量num加1我们知道全局队列是一个并发队列，这里你也可以像上边的例子一样自己创建一个并发队列</li><li>并发队列有多个出口，允许多个任务同时执行，异步任务不会阻塞线程并且会先加入队列等待调度执行</li><li>num只有在while循环里边才会进行+1，所以最少要加10次才会变成10，也就是最少会有10个异步任务被加入队列</li><li>但是通过第3步我们知道任务进去后不一定立马被执行，可能一个num++任务加入队列后还没来记得执行，while已经开始了下一次循环又将一个任务加入队列（取决于你的CPU状态），所以num可能被额外的++，而循环可能在某次++后跳出，但是队列中可能还有++任务未被调度</li><li>那么最低次数 10 + 额外次数 一定大于等于10，结果应该就是大于等于10<br>来看一下打印</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028a58c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">4</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000288a500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">5</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028bf680</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br><span class="line"><span class="number">3</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028be7c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">6</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028a58c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">7</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000288a500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028be4c0</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;</span><br><span class="line"><span class="number">9</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028bf680</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br><span class="line"><span class="number">8</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028dc2c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">10</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028bf680</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br><span class="line"><span class="number">11</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028a58c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">12</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028be4c0</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;</span><br><span class="line"><span class="number">16</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028bf680</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br><span class="line"><span class="number">15</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028be7c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">20</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028bf680</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="number">12</span>--&lt;_NSMainThread: <span class="number">0x600002880000</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">22</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028be7c0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">23</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000028bf680</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br><span class="line"><span class="number">17</span>--&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000288a500</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看出循环外的log打印的是12，多余的打印就是额外加入队列的任务</p><h3 id="后记">后记</h3><p>通过上边几个例子，我想你对于GCD的使用应该更加的熟悉了，但是这里只是列举了几种使用相对简单的场景，我们实际中可能需求更复杂，比如多个网络请求结束后执行某些操作，或者多个请求之间有依赖，或者对于某些数据要实现多读单写等，这里是抛砖引玉，先对基本使用有更深刻的理解，然后后续会结合更复杂的场景来介绍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;GCD（1）任务的顺序&lt;/h1&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;GCD这个东西老生常谈了，我们在开发中还是比较常用，几乎我们每个项目中都会用到,但是频率却又不是特别高（先别反驳）。&lt;/p&gt;
&lt;p&gt;因为可能只是个别对操作有特殊要求的</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://lazy.wiki/tags/iOS/"/>
    
    <category term="GCD" scheme="https://lazy.wiki/tags/GCD/"/>
    
    <category term="多线程" scheme="https://lazy.wiki/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络(2)--IP分类,网段确定</title>
    <link href="https://lazy.wiki/posts/4947d79c/"/>
    <id>https://lazy.wiki/posts/4947d79c/</id>
    <published>2022-05-24T13:01:56.000Z</published>
    <updated>2022-05-28T16:03:30.151Z</updated>
    
    <content type="html"><![CDATA[<p>由于本系列是我个人在疫情期间心态的变化而重新学习网络后的总结，因此许多细节我并不会详细解释，默认读者已经知道，比如此处IP是什么东西，在OSI的第几层等内容，不过有些地方我会给出相应的解释链接</p><h1><a class="link"   href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/150859?fr=aladdin" >IP地址(Internet Protocol Address)<i class="fas fa-external-link-alt"></i></a></h1><ul><li>IPv4：32位，4字节表示（2019年1月25日全球可用IP地址已用完）</li><li>IPv6：128位，16字节</li></ul><p>我们这里先介绍IPv4</p><h2 id="IPv4">IPv4</h2><ul><li>按字节分四部分组成，每部分1个字节，也就是8位，但是直接显示二进制不便于读写，所以一般我们转成十进制表示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205241654289.png"                      alt=""                ><br>按功能分两部分网络标识（网络ID）和主机标识（主机ID）<br>同一网段网络ID相同，</li></ul><h3 id="子网掩码（subnet-mask">子网掩码（subnet mask)</h3><p>网段通过子网掩码计算，通过<code>子网掩码 &amp; IP地址</code>计算网段,举例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IP地址：192.168.1.10</span><br><span class="line">子网掩码：255.255.255.0</span><br><span class="line">-----------------------</span><br><span class="line">  1100 0000.1010 1000.0000 0001.0000 0000  -&gt; IP地址（二进制）</span><br><span class="line">&amp; 1111 1111.1111 1111.1111 1111.0000 0000  -&gt; 子网掩码（二进制）</span><br><span class="line">-------------------------------------------</span><br><span class="line">  1100 0000.1010 1000.0000 0001.0000 0000  -&gt; 网段（二进制）</span><br><span class="line">  192.168.1.0                              -&gt; 网段(十进制)</span><br><span class="line">  所以，这个例子中的192.168.1.0就是网段（网络ID），而最后一位就用来表示主机（主机ID）</span><br></pre></td></tr></table></figure><p>不能直接把IP地址的前三部分当做网段，网段必须是通过<code>子网掩码 &amp; IP地址</code>来计算，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP地址：130.168.1.10</span><br><span class="line">子网掩码：255.255.0.0</span><br><span class="line">网段：130.168.0.0 -&gt; 最后两位表示主机，主机位要从1开始</span><br></pre></td></tr></table></figure><p>一个地址主机位全0就代表这是一个网段，主机位全255就表示这是个广播IP，给这个IP发消息就是给这个网段的所有主机发消息</p><h3 id="地址分类">地址分类</h3><p>那么到底怎么确定网段呢？IP地址其实有分类，不同类别的IP地址网络标识部分长度不同，也就是网段部分长度也就不同，同样的主机位长度也不同，那么不同类别的IP地址网段内容纳的主机数也就不同</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205241659036.png"                      alt="地址分类"                ></p><p>比如A类地址由8位网络ID和24位主机ID组成，举例<code>1.168.1.1</code>，子网掩码<code>255.0.0.0</code>，那么网段就是<code>1.0.0.0</code></p><p>主机位长度不同，对应的网段能容纳的主机数也就不同，主机位可以容纳的主机个数就是 <code>主机位最大值-2</code><strong>（因为255为广播地址，0用来表示网段）</strong></p><h4 id="A类地址">A类地址</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205241659568.png"                      alt=""                ><br>因为第一部分8位表示网络ID，并且必须以0开头，那么二进制取值范围就是<code>0000 0000 - 0111 1111</code>转化成十进制就是<code>0-127</code></p><h5 id="网络ID部分">网络ID部分</h5><ul><li>全0不能用</li><li>127位保留网段，我们常用的127.0.0.1是本地环回地址（Lookback）代表本机地址，它不属于任何一个有类别地址类。代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口</li><li>综合上边两条 A类地址网段范围就是<code>1-126</code></li></ul><h5 id="主机ID部分">主机ID部分</h5><ul><li>主机ID部分三字节三部分，每部分取值范围是0-255</li><li>每个A类网络（网段）能容纳的主机数为256 * 256 * 256 -2 = 2^24 - 1 = 16777214（减去255和0）</li></ul><h4 id="B类地址">B类地址</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205241704980.png"                      alt=""                ><br>因为前两部分16位表示网络ID，并且必须以10开头，那么二进制取值范围就是<code>1000 0000 0000 0000 - 1011 1111 1111 1111</code>转化成十进制就是<code>128.0-191.255</code></p><h5 id="网络ID部分-2">网络ID部分</h5><ul><li>第一部分取值范围128-191</li><li>第二部分取值范围0-255</li><li>C类地址网段范围就是<code>128.0-191.255</code></li></ul><h5 id="主机ID部分-2">主机ID部分</h5><ul><li>第三地部分取值范围都是0-255</li><li>每个B类网络（网段）能容纳的主机数为256 * 256 -2 = 2^16 - 2 = 65534</li></ul><h4 id="C类地址">C类地址</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205241659590.png"                      alt=""                ><br>因为前三部分24位表示网络ID，并且必须以110开头，那么二进制取值范围就是<code>1100 0000 0000 0000 0000 0000 - 1101 1111 1111 1111 1111 1111</code>转化成十进制就是<code>192.0.0-223.255.255</code></p><h5 id="网络ID部分-3">网络ID部分</h5><ul><li>第一部分取值范围192-223</li><li>第二,三部分取值范围0-255</li><li>C类地址网段范围就是<code>192.0.0-223.255.255</code></li></ul><h5 id="主机ID部分-3">主机ID部分</h5><ul><li>第四地部分取值范围都是0-255</li><li>每个C类网络（网段）能容纳的主机数为256 - 2 = 254</li></ul><h4 id="D-E类地址">D,E类地址</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205241659604.png"                      alt=""                ></p><p>那么我们其实可以快速的通过一个IP地址的第一部分来判断它属于什么类型进而确定网段范围和主机范围</p><table><thead><tr><th style="text-align:center">第一部分</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">0~127</td><td style="text-align:center">A类</td></tr><tr><td style="text-align:center">128~191</td><td style="text-align:center">B类</td></tr><tr><td style="text-align:center">192~223</td><td style="text-align:center">C类</td></tr><tr><td style="text-align:center">224~239</td><td style="text-align:center">D类</td></tr><tr><td style="text-align:center">240~255</td><td style="text-align:center">E类</td></tr></tbody></table><p>比如看到一个IP<code>110.110.110.110</code>通过第一部分立马能判断吃它是A类地址</p><h4 id="子网掩码CIDR表示法">子网掩码CIDR表示法</h4><p>为了方便的表示IP和子网掩码，它们也可以写在一起，像下边这样</p><ul><li>192.168.1.100/24,代表IP为<code>192.168.1.100</code>,子网掩码是<code>24个二进制1</code>也就是<code>255.255.255.0</code></li><li>191.100.1.100/16,代表IP为<code>191.100.1.100</code>,子网掩码是<code>16个二进制1</code>也就是<code>255.255.0.0</code></li></ul><hr><p><a href="https://lazy.wiki/posts/49b8739d/">网络(1)–网络通讯的基础</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于本系列是我个人在疫情期间心态的变化而重新学习网络后的总结，因此许多细节我并不会详细解释，默认读者已经知道，比如此处IP是什么东西，在OSI的第几层等内容，不过有些地方我会给出相应的解释链接&lt;/p&gt;
&lt;h1&gt;&lt;a class=&quot;link&quot;   href=&quot;https://</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="重学开发" scheme="https://lazy.wiki/tags/%E9%87%8D%E5%AD%A6%E5%BC%80%E5%8F%91/"/>
    
    <category term="网络" scheme="https://lazy.wiki/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络(1)--网络通讯的基础</title>
    <link href="https://lazy.wiki/posts/49b8739d/"/>
    <id>https://lazy.wiki/posts/49b8739d/</id>
    <published>2022-05-23T09:42:14.000Z</published>
    <updated>2022-05-28T15:35:44.064Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="前言">前言</h3><p>关于网络，其实对于我们客户端开发，网络部分绝大多数内容都是在应用层，多了就是再涉及点传输层的内容，但是为了了解计算机网络通信的整个逻辑，我想更深入的去学习网络的相关知识，这对于我们理解计算机，认清我们所处的网络世界，更快的解决开发中遇到的网络问题其实是很有帮助的，所以我打算从头开始学习网络相关内容</p><p>由于本系列是我个人学习过程中对网络内容的总结，因此更像是笔记性质，并且由于理解能力的问题，可能会出现表述错误的地方，所以这不是针对于网络和开发初学者的教程，以免误人子弟，如果在看的过程中发现有理解或表达错误的地方，还请见谅，也烦请指出，以便我去改正，感谢</p><h3 id="计算机通信基础">计算机通信基础</h3><ol><li>IP地址：通过IP地址找到主机</li><li>MAC地址（网卡地址）：网卡接收数据决定要不要继续处理</li></ol><h3 id="连接方式">连接方式</h3><h4 id="网线直连">网线直连</h4><p>两台设备间通过交叉线直连通信，知道对方ip后先通过ARP广播获取对方mac地址，ARP广播会给同网段所有链接的设备发送消息询问mac地址，接收方收到询问后发现是找自己的mac地址则回复自己的mac地址，如果不是找自己就丢弃不处理</p><h4 id="同轴电缆">同轴电缆</h4><p><strong>优点：</strong></p><ol><li>可以连接多台设备，</li></ol><p><strong>缺点：</strong></p><ol><li>半双工通信（双发可以互发消息但不能同时）</li><li>不安全，arp会讲广播发给连接的所有设备</li><li>某一段断掉，网络瘫痪</li></ol><p>连接的多台设备当有设备同事发消息，就会产生冲突，这样就形成了一个冲突域，</p><h4 id="集线器">集线器</h4><p>同同轴电缆类似，只不过当某一段断掉，不影响其他设备</p><h4 id="网桥">网桥</h4><ol><li>可以连接多个集线器，但又能隔绝冲突域</li><li>可以记录mac地址，当arp广播询问mac地址时，会记录请求与响应设备的mac地址，当再次有arp广播时，会判断记录的mac地址属于哪个冲突域，然后只将消息发送到这个域</li></ol><h4 id="交换机">交换机</h4><ol><li>全双工通信</li><li>集线器与网桥功能的结合体，可以记录mac地址，又能连接多个设备</li><li>比集线器安全</li></ol><h4 id="路由器">路由器</h4><p>以上的几种通信方式要求：</p><ol><li>连接的设备要在同一网段</li><li>连接的设备在同一广播域</li></ol><p>那么如果全世界的设备都通过以上方式连接，所有设备就在一个网段也就是同一个广播域，一个设备发送ARP广播，其他几十亿设备都会收到，这是不安全的，并且这样做IP地址也会不够</p><p>所以怎么在不同网段通信？路由器可以解决</p><ol><li>可以在不同网段发送数据</li><li>可以隔绝广播域</li></ol><p><strong>概括·</strong></p><ol><li>路由器上有多个网关端口，每个网关可以设置自己的IP，通过设置IP地址（和要连接的网段一致）接入一个网段，通过此方式可以将多个网段连接起来</li><li>计算机发起通信前会判断目标IP和自己是否属于同一网段，如果是，则发起ARP广播获取目标MAC地址，如果不是则发起ARP广播获取网关的MAC地址；获取MAC地址前提是知道IP，计算机只知道自己要发送目标的IP，并不知道网关的IP，所以计算机的网络设置中如果是静态配置要手动配置一个默认网关地址（计算机网络设置中，显示&quot;路由器地址&quot;指的就是路由器网关地址），如果是DHCP则会自动获取</li><li>获取到网关MAC地址后将数据包发给网关</li><li>网关收到数据包后，通过目标网段对应的网关，发送ARP广播到对应网段获取目标MAC地址</li><li>目标设备收到数据后，回传数据给源设备完成跨网段通信</li></ol><h3 id="MAC地址">MAC地址</h3><p>每个网卡都有一个全球唯一的MAC地址，固化在网卡硬件上，它由6字节也就是48位标识，前三字节由IEEE（注册管理机构）分配给厂商，后三字节厂商自行分配，<a class="link"   href="https://standards-oui.ieee.org/oui/oui.txt" >查看地址<i class="fas fa-external-link-alt"></i></a><br>MAC地址一般长这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8A-7B-6C-01-23-45(Windows)</span><br><span class="line">或</span><br><span class="line">8A:7B:6C:01:23:45(MacOS)</span><br></pre></td></tr></table></figure><ul><li>MAC地址可以修改（网卡硬件的不能修改，但是我们可以给电脑设置一个虚拟的MAC地址，这样系统就会使用设置的这个MAC地址，而不是网卡本身的MAC地址）</li><li>有时因为交换机等的人为配置的限制，不在允许范围内的MAC地址的设备不能上网，那么我们可以拿到允许上网设备的MAC地址，将自己的进行修改，来进行蹭网，但是同一个网段有两台设备具有相同的MAC地址，同时间其中一台设备是不能上网的</li><li>通信过的设备会缓存目标的IP和MAC地址的映射关系<code>arp -a</code>查看</li><li>如果A设备的网卡换了，而其他设备缓存的有A设备的IP和MAC地址，这时候再向A通信会失败，这时候会重新发送ARP广播获取新的MAC地址</li><li>也可以手动给设备添加IP和MAC的映射关系<code>arp -s IP地址 MAC地址</code></li></ul><h3 id="补充">补充</h3><ul><li>同一个网段，代表在同一个广播域，代表可以收到同样的ARP广播</li></ul><h4 id="ARP协议"><a class="link"   href="https://baike.baidu.com/item/ARP/609343?fr=aladdin" >ARP协议<i class="fas fa-external-link-alt"></i></a></h4><p>工作过程<br>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；<br>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；<br>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ol><li>根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li><li>如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li><li>主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li><li>当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ol><p>如果目标MAC地址全是F则表示这是一个广播</p><h4 id="ICMP协议"><a class="link"   href="https://baike.baidu.com/item/ICMP/572452?fr=aladdin" >ICMP协议<i class="fas fa-external-link-alt"></i></a></h4><p>ICMP是“Internet Control Message Protocol”（Internet控制消息协议）的缩写。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。<br>ICMP唯一的功能是报告问题而不是纠正错误，纠正错误的任务由发送方完成。<br><strong>ping命令使用的就是ICMP协议</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;关于网络，其实对于我们客户端开发，网络部分绝大多数内容都是在应用层，多了就是再涉及点传输层的内容，但是为了了解计算机网络通信的整个逻辑，我想更深入的去学习网络的相关知识，这对于我们理解计算机，认清我们所处的网</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="重学开发" scheme="https://lazy.wiki/tags/%E9%87%8D%E5%AD%A6%E5%BC%80%E5%8F%91/"/>
    
    <category term="网络" scheme="https://lazy.wiki/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>疫情于我</title>
    <link href="https://lazy.wiki/posts/6a6dcc9e/"/>
    <id>https://lazy.wiki/posts/6a6dcc9e/</id>
    <published>2022-05-22T10:22:14.000Z</published>
    <updated>2022-05-22T10:27:20.657Z</updated>
    
    <content type="html"><![CDATA[<p>受疫情影响，截止到今天，我已经居家办公59天，足不出户封闭52天，这将近两个月的是将，我的心态不断变化，甚至可能影响以后的我。</p><h3 id="天真">天真</h3><p>其实在我没有开始居家办公的时候，疫情已经小规模扩散开了，我记得通知居家办公前几天，我们公司还有一位同事不幸确诊，当时我们也是人心惶惶，心里边多少有点害怕，不过因为不在同一个楼层，并且在他确诊前后也没有来过我们楼层，所以虽然害怕，但是也相信政府和公司，并没有太多担心。<br>在真正通知居家办公时，只有浦东，徐汇等区比较严重，我所在的区还好，起码那几天出门，交通都没有限制，不过按照当时的趋势，我也明白我们封闭也只是时间问题，所以那几天我就尽量每天出门买菜，说实话，那几天买菜明显感觉到菜价比平时贵了许多，娃娃菜，生菜等常吃的都涨到了七八块，青椒将近十块，而本来已经降价的猪肉也重新涨到了20+，但是即使贵也要买，心想就这一段，过去了就好了，但后来铺天盖地的负面事实证明，我太天真了。</p><h3 id="食物">食物</h3><p>大概是三月底二十七八号左右吧，正式通知要足不出户居家隔离，以黄浦江为界，浦西开始时间从四月一号开始，到四月五号，我就在浦西，当时我是真的相信到四月五号会结束封闭，我还劝我女朋友，魔都毕竟是魔都，不用太过担心，这时候其实我储备了大约一周的食物，都是提前买的，包括菜油大米之类的，但事实证明我确实对上海抱有了过分的信心。<br>第一天小区还发了物资，我之前就听说上海政府会在隔离期间发放物资，但是我收到的第一次物资实在是一言难尽，当时我就想，除非实在没有吃的，否则绝不动用这次的物资，<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/Lazyloadingg/img-blog/master/img/202205221649723.jpg"                      alt="第一次物资"                ><br>四月五号，并没有解封，但这时候，菜市场已经关闭，美团买菜，盒马，叮咚买菜也都被关闭，我终于意识到，网上流传的，在家没有吃的等死的事情，真的会发生，后续的事情大家也都知道，各个区都开始有倒卖物资，高价团购，以物易物等，后续又发放了四五次物资，都很不错，我也很感谢社区，感谢伸出援手的企业</p><p>整体来看，直到现在，疫情在家两个月，虽然瘦了十斤左右，但是在有团购和物资的情况下，我并没有感觉自己被饿到。</p><h3 id="医疗">医疗</h3><p>这还不止，吃只是一方面，要知道疫情下社会停摆的影响是巨大的，医疗资源挤兑严重，大部分的医疗资源都被调去优先处理解决疫情，那么其他患者获得的医疗资源就会减少，甚至是没有，果然，没过几天，网上开始爆出各种，化疗无法就医，孕妇无法就医，其他病症就医因不能出具有效核酸证明而被拒之门外导致耽误最佳治疗时间，加重了病情甚至死亡，著名经济学家郎咸平的母亲也收到了影响，真的是应了那句话，时代的一粒灰，落在一个家庭，一个人身上就是一座山。</p><p>为了尽快结束疫情，核酸检测一次接一次，但中间有个插曲让我觉得无法理解，我们楼上有邻居确诊被拉去方舱，可是作为同一栋楼的我们，居然在三天后才知道这件事，这中间我们还每天下楼丢垃圾，知道这件事情后我们非常气愤，询问为什么居委不告知我们?同一栋楼的我们不更应该知道，然后做好防护措施吗？而这时候的居委就像消失了一样，群里@也毫无反应，不过还好，最后大家都没事，但是你以为就这么结束了吗？并没有。</p><p>自从楼栋出现确诊后，本来几天做一次的核酸检测也停了，注意停的只是我们，到了检测日期，其他楼栋都是正常检测， 唯独将我们楼忽略了，询问居委，得到的回答是，大白从上午工作到下午两三点累了，改天再做。我？？？，我们50号楼，旁边的49号，51号都做了我们就在他们中间没有做是因为大白累了？？？这时候我们其实根本不相信他的说辞，大家都开始猜测，是不是因为楼上有确诊，害怕我们也有感染处于潜伏期，下楼做核酸再感染其他人，但是这种情况的我们不是更应该做检测？如果不能下楼去做，检测最后大白上门做总可以吧？既然检测力度这么大，甚至将其他的医疗资源都优先用于新冠疫情，做到这点不是更应该？总之这件事让我无法理解。</p><p>这中间有件事也让我彻底吓坏了，但是又只能强作镇定，我女朋友突然发烧了，最高到38.4，明明中午吃饭时候还好好的没问题，下午三点钟就开始觉得不舒服，量了下体温37.6，我让她吃了点社区发放的连花清瘟，因为家里没有其他的退烧药，只有这个写的有退烧功效，但事实证明并没有什么卵用，吃过药后过了一个半小时再次量体温，烧的更严重了，我开始在群里询问哪位邻居家有药，很幸运邻居们都很有爱，纷纷说自己家里有你可以过来拿，于是我去了最先回答的那位邻居家，他们给的是布洛芬，不过是小孩子吃的那种，但据他说他之前吃过有效，回去立马让我女朋友吃了点后让他睡下，到了奖金八点，再次量体温，降下来了点，但是仍然在37度多点，这时候我看距离上次吃药已经过了将近四个小时，于是又让她吃了点睡下。</p><p>第二天早上起床后就立马量体温，还是37度，不过我已经不像昨晚那么担心了，后续又发生了很多事，有其他邻居给了头孢，居委打电话询问病情，本计划的全员核酸也不让我们去做了，最后还是以为热心的大白上门给我女朋友做了核酸，她在前一天还送了退烧贴给我们，我真的很感谢她，后来本以为没事了，谁想到提问重新升到了38左右，这时候我是真的有点恐慌了，但是如果我表现的很明显的话只会让情况更糟，所以只能故作镇定，我开始联系大白和居委如何才能去医院，而邻居也开始不断的说让我们去医院，我明白，这时候发烧，不是一个人的事情，其实邻居们也还怕，但是我没想到我女朋友会抗拒，好说歹说就是不愿去医院，我很无奈甚至有点生气，在外邻居们在非议，当然他们也是出于好心我并不怪罪他们，反而感谢他们伸出援手，在内还要被女朋友怪罪说把病情发在群里，说实话我那时候确实有点生气，但是忍了下来，我说到中午，如果体温还起伏的话，别再说别的，去医院，这次他终于答应，很幸运，中午的体温正常了，后边每隔一个小时都量一次体温，直到晚上都没有异常，此时我悬着的心终于放了下来，哎。</p><h3 id="工作">工作</h3><p>由于工作性质的原因，虽然居家办公，但其实对工作效率的影响并不大，依然是每天晨会沟通工作计划，视频会议沟通各种需求，技术方案，随后开发，测试等等。一切有条不紊的推进。</p><p>但是大概在居家二十多天，将近一个月后，我开始变得有点烦躁，开始怀念去公司上班的日子，因为我发现居家办公久了之后，很容易被其他事情分散注意力，很难专注在工作上，对于不太复杂的任务还好，相对复杂一点的任务这种状态是不可取的，我询问了朋友和同事，发现他们都有这种感受，我不知道这是错觉，还是因为隔离久了后情绪发生的莫名的变化</p><h3 id="学习">学习</h3><p>有更多的在家时间，也意味着有更多的时间可以放在工作之外，比如游戏，音乐，社交软件等等，但是同样在一段时间后，突然有那么些瞬间，觉得这些都无关紧要，也可能是因为每天都吃自己爱吃的菜同样会腻的原因；这中间的一天我无意中打开脉脉，突然认识到一件事，疫情导致社会的停摆，怎么可能只影响到吃喝与医疗？看看脉脉不断有人哀叹失业，哀叹工作难找就明白了，疫情的影响是方方面面的！</p><p>我终于开始关注之前被我不自觉忽略的新闻，就业形势，大厂裁员，季度GDP大幅下降，这让我恐慌，恐慌情绪支配下的我，对于什么游戏，社交，更加失去兴趣，我开始想，我如果被毕业了怎么办，我如果被社会淘汰了怎么办？我的房租，房贷，吃穿用度怎么办？这让我非常焦虑，好几个夜晚，躺在床上都在想这些事情，特别是看到我那小傻瓜一样的女朋友每天就是看看韩剧，看看综艺，刷刷微博，看看吃播我就更无语，我心想，你难道从来不担心这些的吗？万一我失业了交不起房租，我们住哪？万一将来找不到工作，房贷逾期怎么办？</p><p>连续几天我被这种焦虑情绪支配，我知道我不能一直这样，我开始想办法摆脱这种困境，于是我开始看书，开始看技术文章，开始学习，其实我一直有在学习，但之前的纯属于兴趣使然，从没有像这样担心将来到焦虑，逼着自己去学习。</p><p>连续一周不停的学习，白天有空就看文章，晚上吃了饭就开始敲代码验证想法，甚至关了灯躺在床上还在想，这么问题怎么解决？事后来看，那几天的我简直魔怔了，魔怔到有点好笑，虽然现在我学习的强度比前一段有所下降，但是依然保持每天学习从不拉下，而就这么持续了一二十天后，我发现这中间我完全没想起来去玩游戏，是真的没想起来，就想他们本身就不存在一样，而这种状态下得我感到了一种格外的充实和安全感。</p><p>而这中间我也认识到了很多的不足，所以暂时有个想法，我想重新开始学习开发，从那些最基础的，最简单的东西开始，把自己当成一个初出校门的小白，重新认识自己这个行业。</p><p>再后来，我不满足于看电子书，看技术文章，看源码，看视频，我翻出了吃灰许久的实体书籍，开始得空就在阳台坐着翻看，安静的傍晚，或是夜幕降临后，坐在沙发上，一个人看着书，偶尔抬头望向我那小傻子一样又在看不知道什么综艺的女朋友，我觉得，可能现在的我想太多只会让自己变得更加沮丧，在疫情下无法出门，社会停摆，无论什么想太多都是一种负担，不如趁这段时间提升自己，不是有那句话吗，你若盛开，蝴蝶自来。</p><h3 id="最后">最后</h3><p>啰嗦了这么多，都不知道自己在说些什么了，在家这两个月还发生了许多事情，有好的，有坏的，很多都没有在这里写出来，有关于个人的，有关于这座城市的，但是这两个月下来我的心态确实发生了变化，对工作，对生活，对学习，或许这种心态会影响我一生，或许是一阵，这知道呢，不过我清楚的是，无论影响多久，这都是我，我走过的路，我经历过的好的，坏的，所有事情，构成了现在的我，用一句话来说就是，我与我周旋久，宁做我。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;受疫情影响，截止到今天，我已经居家办公59天，足不出户封闭52天，这将近两个月的是将，我的心态不断变化，甚至可能影响以后的我。&lt;/p&gt;
&lt;h3 id=&quot;天真&quot;&gt;天真&lt;/h3&gt;
&lt;p&gt;其实在我没有开始居家办公的时候，疫情已经小规模扩散开了，我记得通知居家办公前几天，我们公司还</summary>
      
    
    
    
    <category term="随笔" scheme="https://lazy.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="疫情" scheme="https://lazy.wiki/tags/%E7%96%AB%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>load和initialize区别</title>
    <link href="https://lazy.wiki/posts/a696ae61/"/>
    <id>https://lazy.wiki/posts/a696ae61/</id>
    <published>2022-04-29T01:47:41.000Z</published>
    <updated>2022-05-21T08:27:14.931Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最近在群里突然有群友问load和initialize区别，我心想这不简单吗，脑海中瞬间冒出两条，然后就想不起来了，然后看到群友七嘴八舌一人一个说法，我就寻思重新回顾下这个知识点，遂做个回顾。</p><p>这篇文章是我结合网上资料，官方文档，和runtime源码整理得出的，在说明结论时我会在结论前附带官方文档解释并会在（）附带自己的理解，如果理解有误还请指正；你也可以写个demo去验证，我顺手在项目中验证了下所以就不贴代码了。</p><h3 id="调用方式">调用方式</h3><blockquote><ul><li>OBJC_EXPORT void _objc_load_image(HMODULE image, header_info *hinfo)<br>{<br>prepare_load_methods(hinfo);<br>call_load_methods();<br>}<br>可以下载源码(objc4-818.2源码)点<code>objc-os</code>文件进去查看<code>_objc_load_image -&gt; call_load_methods -&gt; call_load_methods -&gt; call_class_loads -&gt; (*load_method(cls,@selector(load));</code></li></ul></blockquote><ul><li>load通过函数地址调用</li></ul><blockquote><ul><li>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</li></ul></blockquote><ul><li>initialize通过objc_msgSend（runtime消息发送）调用</li></ul><h3 id="调用时机">调用时机</h3><blockquote><ul><li>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</li></ul></blockquote><ul><li>load是runtime加载类、分类的时候调用(只会调用一次)</li></ul><blockquote><ul><li>Initializes the class before it receives its first message.</li><li>The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].</li></ul></blockquote><ul><li>initialize是类第一次接收到消息的时候调用（可以在main前也可以在后，看什么时候第一次接收消息）, 每一个类只会initialize一次(如果子类没有实现initialize方法, 会调用父类的initialize方法, 所以父类的initialize方法可能会调用多次)</li></ul><p><strong>以上的调用一次指的是程序生命周期内默认只调用一次，但是如果你手动调用的话还是会调用多次</strong></p><h3 id="调用顺序">调用顺序</h3><blockquote><ul><li>A class’s +load method is called after all of its superclasses’ +load methods.</li><li>A category +load method is called after the class’s own +load method.</li></ul></blockquote><ul><li>load<ol><li>先调用类的load, 再调用分类的load</li><li>先调用父类的load，再调用子类的load</li><li>先编译的类（分类），先调用</li></ol></li></ul><blockquote><ul><li>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</li><li>The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize].</li></ul></blockquote><ul><li>initialize<ol><li>先调用父类，再调用子类（即使你先给子类发消息，子类默认也会先调用父类）</li><li>如果子类没实现initialize，会向上调用父类</li><li>如果分类实现initialize，则会覆盖本类的initialize（因为是objc_msgSend消息发送调用，分类方法加载时会插入在本类前）</li></ol></li></ul><h3 id="资料">资料</h3><ul><li>如果你不清楚怎么查看官方文档:<br><code>  Xcode -&gt; Help -&gt; Developer Documentation</code><br>或者你也可以下载<code>Dash</code>查阅</li><li>如果你想查看源码：<br><a class="link"   href="https://opensource.apple.com/tarballs/objc4/" >runtime源码下载<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;最近在群里突然有群友问load和initialize区别，我心想这不简单吗，脑海中瞬间冒出两条，然后就想不起来了，然后看到群友七嘴八舌一人一个说法，我就寻思重新回顾下这个知识点，遂做个回顾。&lt;/p&gt;
&lt;p&gt;这篇文章是我结合网上资料，官方文档，和ru</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://lazy.wiki/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《人类简史：从动物到上帝》随性笔记</title>
    <link href="https://lazy.wiki/posts/6e29e650/"/>
    <id>https://lazy.wiki/posts/6e29e650/</id>
    <published>2022-03-24T09:22:48.000Z</published>
    <updated>2022-05-21T08:27:14.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《人类简史：从动物到上帝》笔记">《人类简史：从动物到上帝》笔记</h2><p>这本书是年前看视频还是刷微博什么的看到别人推荐的，忘了，记录下看书过程中记下的笔记（和吐槽），持续随性阅读更新</p><h3 id="第一部分-认知革命">第一部分 认知革命</h3><p><strong>第二章 知善恶树</strong></p><blockquote><p>通过文字创造出想象的现实，就能让大批互不相识的人有效合作，而且效果还不只如此。正由于大规模的人类合作是以虚构的故事作为基础，只要改变所讲的故事，就能改变人类合作的方式。</p></blockquote><p>脑海中突然冒出个想法，传销吗这不是haha~</p><p><strong>第三章 亚当和夏娃的一天</strong></p><blockquote><p>在现代的富裕社会，平均每周的工时是40~45小时，发展中国家则是60甚至80小时；但如果是狩猎采集者，就算住在最贫瘠的地区（像是卡拉哈里沙漠），平均每周也只需要工作35~45小时。他们大概只需要每三天打猎一次，每天采集3~6小时</p></blockquote><p>现代人社畜无疑了~</p><blockquote><p>也因为采集者不依赖单一种类的食物，就算某种食物来源断绝了，影响也不会太大。但如果是农业社会，一旦来场干旱、火灾、地震，把当年的稻子或马铃薯摧毁殆尽，就会引发严重的饥荒。虽然采集社会还是难以幸免于自然灾害，而且也会碰上食物短缺或饥荒的情形，但通常他们处理起来就是比较游刃有余</p></blockquote><p>这点我不能同意，人类进入农业社会就是为了解决食物短缺开源不稳定的问题，这也是自然选择导致的生存方式变化，人类发现农业之前的采集社会食物开源虽然多样但是不稳定，吃了上顿没下顿，抵抗自然灾害的能力更差，看看现在的各种野生动物，难道在食物上都比人类富足？或者去看几百年前北方的游牧民族，不断进入中原农业社会掠夺，如果这种生存方式更优越，为什么他们会如此做？</p><h3 id="第二部分-农业革命">第二部分 农业革命</h3><p><strong>第五章 史上最大骗局</strong></p><blockquote><p>第一，小麦不喜欢大小石头，所以智人得把田地里的石头捡干净搬出去，搞得腰酸背痛。第二，小麦不喜欢与其他植物分享空间、水和养分，所以我们看到男男女女在烈日下整天除草。第三，小麦会得病，所以智人得帮忙驱虫防病。第四，不论是蝗虫还是兔子，都不排斥饱尝一顿小麦大餐，但小麦完全无力抵抗，所以农民又不得不守卫保护。最后，小麦会渴，所以人类得从涌泉或溪流大老远把水引来，为它止渴；小麦也会饿，所以智人甚至得收集动物粪便，用来滋养小麦生长的土地。</p></blockquote><p>作者一直在阐述采集社会优于农业社会，或者说单就食物这方面说，优于农业社会，包括在多样性和稳定住方面，我不能苟同，早先多样性是因为没得吃，什么能吃吃什么，总的来说就是吃点东西别让自己饿死，并且农业社会后并不是就不具备多样性了，而是变得以某几种为主，并没有说拒绝吃其他食物，并且，从采集到农业有两个很大的优点是促使人类彻底转变的原因，一个是安全，一个是稳定，采集狩猎社会获取食物，你需要和野兽斗智斗勇，试试小心别让自己受伤，以那个时候的医疗条件，受伤严重点基本等于已经死了，人们都是趋利避害的，而农业种植的安全性要远大于采集狩猎，另一个稳定，前文作者也说了，人类是种族灭绝的元凶，原始社会的人类并没有可持续发展的观念，遇到什么能吃什么就打来吃，他们不知道竭泽而渔的道理（并不绝对），那么可采集狩猎的食物在较长的时间跨度里，是在慢慢减少的，这也是他们不断迁徙的原因之一，看看现在的许多动物仍是如此，而这种情况下的农业种植，恰恰提供了持续的产出，或许他们不懂得可持续发展的道理但是一季又一季的种植，不断的收获，这是看的到的产出；作者虽然说会容易收到自然灾害病虫害的影响，首先自然灾害都是区域性大面积的，如果真有自然灾害，难道只影响你的耕地？不影响你原始的食物采集区？显然不是的，天地不仁以万物为刍狗，大自然和你非亲非故不会特殊照顾你，至于什么平整土地刨除石头之类得，这些工作的难度依然小于采集狩猎，并且是一次性的，一片土地的石头刨除后，明年有不会再长出来对不对？而植物养料的获取难度在人类定居在耕地附近后其实容易获取，难道采集社会的职务就不需要粪便养料？那时候难道不是更难获取？归根结底农业种植活动其实就是固定一片区域的采集狩猎活动，采集的是你种植的植物，狩猎的是你圈养的动物，只不过变得更加稳定和安全了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;《人类简史：从动物到上帝》笔记&quot;&gt;《人类简史：从动物到上帝》笔记&lt;/h2&gt;
&lt;p&gt;这本书是年前看视频还是刷微博什么的看到别人推荐的，忘了，记录下看书过程中记下的笔记（和吐槽），持续随性阅读更新&lt;/p&gt;
&lt;h3 id=&quot;第一部分-认知革命&quot;&gt;第一部分 认知革命&lt;/h</summary>
      
    
    
    
    <category term="随笔" scheme="https://lazy.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="读书笔记" scheme="https://lazy.wiki/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage链接重定向问题处理</title>
    <link href="https://lazy.wiki/posts/7f6c5879/"/>
    <id>https://lazy.wiki/posts/7f6c5879/</id>
    <published>2022-03-14T12:01:58.000Z</published>
    <updated>2022-05-21T08:27:14.934Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Round-1">Round 1</h4><p>最近公司的文件服务器进行了改造，即使是图片的加载请求也要携带<code>token</code>，否则无法加载，而我们项目中图片加载用的是<code>SDWebImage</code>,当时听到这个需求我内心毫无波动，心里已经…你懂得，不过该做还是要做，三下五除二写完了代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SDWebImageDownloader sharedDownloader] setValue:<span class="string">@&quot;你的token&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Authorization&quot;</span>];</span><br></pre></td></tr></table></figure><p><code>SDWebImage</code>的下载处理是由<code>SDWebImageDownloader</code>单例类实现，所以在你项目中合适的地方加上这句代码，项目中所有用<code>SDWebImage</code>做图片加载的地方就都会携带上<code>token</code>了</p><h4 id="Round-2">Round 2</h4><p>这样修改完后确实本来不能加载的地方变得正常了，直到那一天，那是一个春天…<br>项目中要添加一个需求，需要引用公司的一个私有<code>Pod</code>功能库，又是一顿操作，集成完毕，逻辑编写完成，run，诶，图片居然没加载出来，我草这什么情况，我再次确认了一下，我的<code>token</code>设置完成了的</p><p>我去询问编写这个<code>Pod</code>的同事，是不是我哪里没配置完成，他略微沉思一下两秒钟后说，你添加完<code>token</code>还要在<code>SDWebImageDownloader</code>修改下源码，我：？？？，随后他找到了这个源码，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response newRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLRequest</span> * _Nullable))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [<span class="keyword">self</span> operationWithTask:task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation respondsToSelector:<span class="keyword">@selector</span>(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session task:task willPerformHTTPRedirection:response newRequest:request completionHandler:completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他解释说道，这个功能模块里的一些图片链接中携带了一些参数，并不是直接指向资源，所以请求会进行重定向，所以需要在这里进行处理，处理后的代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response newRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLRequest</span> * _Nullable))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [<span class="keyword">self</span> operationWithTask:task];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *customRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:request.URL];</span><br><span class="line">    customRequest.allHTTPHeaderFields = <span class="keyword">self</span>.HTTPHeaders;</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation respondsToSelector:<span class="keyword">@selector</span>(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session task:task willPerformHTTPRedirection:response newRequest:customRequest completionHandler:completionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">            completionHandler(customRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我将代码修改后，run，确实，问题解决了，但是不对啊，我们的<code>SDWebImage</code>是通过<code>Pod</code>的方式集成的，这样直接在<code>Pod</code>文件夹下修改三方的源码，那么下次更新后，岂不是被覆盖了？这是一个新的问题，于是我开始思考怎么解决重定向问题的同事不修改三方库的源码，脑海中瞬间就想到了<code>AOP</code></p><p>iOS开发中优秀的<code>AOP</code>库那必须有<code>Aspects</code>名字，接下来我开始思考具体步骤<br>首先，通过同事提供的解决问题的代码来看，他是把参数<code>request</code>给改为了一个自定义的<code>customRequest</code>，这两个的区别，然后重新设置了<code>allHTTPHeaderFields</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableURLRequest</span> *customRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:request.URL];</span><br><span class="line">customRequest.allHTTPHeaderFields = <span class="keyword">self</span>.HTTPHeaders;</span><br></pre></td></tr></table></figure><p>那么我想，问题主要就是在<code>allHTTPHeaderFields</code>这里了，我打印了<code>request</code>和<code>customRequest</code>的<code>allHTTPHeaderFields</code>后发现，前者比后者少了<code>token</code>,怪不得无法加载，这里要提一下下边这个方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response newRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLRequest</span> * _Nullable))completionHandler </span><br></pre></td></tr></table></figure><p>这其实不是<code>SDWebImageDownloader</code>的方法，是<code>NSURLSessionTaskDelegate</code>的里的协议方法，<code>SDWebImageDownloader</code>实现协议方法后在里边做了自己的重定向处理</p><p>那么说一下我一开始的想法，既然问题出在重定向时<code>request</code>里未携带我们手动添加的<code>token</code>，并且重定向这里肯定是要做处理的，那我们直接把相关参数设置给<code>request</code>，没必要创建一个新的<code>customRequest</code>实例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[request setValue:<span class="keyword">self</span>.HTTPHeaders forKey:<span class="string">@&quot;allHTTPHeaderFields&quot;</span>];</span><br></pre></td></tr></table></figure><p>因为<code>request</code>是一个<code>NSURLRequest</code>对象，它的<code>allHTTPHeaderFields</code>是一个<code>readonly</code>属性，我们不能直接修改，所以我想当然的用<code>KVC</code>去操作，<br>然后 run ，然后 我草crash了，报错信息如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[&lt;NSURLRequest 0x2800efa50&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key allHTTPHeaderFields.&quot;</span></span><br></pre></td></tr></table></figure><p>看描述信息是说<code>NSURLRequest</code>没有对应的<code>allHTTPHeaderFields</code>这个key，有那么一瞬间我愣了下，这不科学啊怎么可能没有，我点进<code>NSURLRequest</code>类确认了下，有啊，什么情况，但是本着求知的态度，我心想是不是<code>NSURLRequest</code>内部使用的是不是不叫<code>allHTTPHeaderFields</code>,但是不对啊，这个属性明明在的啊，即使是别的也应该是内部重新赋值我这里不应该报错啊，不过我还是用通过<code>runtime</code>将他的属性列表打印了一下，再次确认了，他确实有<code>allHTTPHeaderFields</code>这个属性，于是我搜索了下相关问题，发现了一个关键词</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)accessInstanceVariablesDirectly</span><br></pre></td></tr></table></figure><p>详细信息自行检索，我这里说下结果，这个是针对<code>KVC</code>的，总的来说，当一个类实现了这个方法并且返回了<code>YES</code>他就可以通过<code>KVC</code>(这个说法不完全准确，因为本文不是针对KVC的故简要说明)赋值，如果返回<code>NO</code>就不可以用<code>KVC</code>赋值</p><p>看到这里后我猜测<code>NSURLRequest</code>里这个方法应该是返回了<code>NO</code>,那完了，走不通了，还是要实例化一个新的对象</p><h4 id="Round-3">Round 3</h4><p>搞了半天想省事看来不行啊，那拉倒，直接开始<code>AOP</code>修改：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> * error ;</span><br><span class="line">[[SDWebImageDownloader sharedDownloader] aspect_hookSelector:<span class="keyword">@selector</span>(URLSession: task: willPerformHTTPRedirection: newRequest: completionHandler:) withOptions:AspectPositionInstead usingBlock:^(<span class="type">id</span>&lt;AspectInfo&gt; aspectInfo, <span class="built_in">NSString</span> *num)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> * param = aspectInfo.arguments;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> * request = param[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSURLSessionTask</span> * task = param[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *customRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:request.URL];</span><br><span class="line">    customRequest.allHTTPHeaderFields = task.currentRequest.allHTTPHeaderFields;</span><br><span class="line">    request = customRequest;</span><br><span class="line">    <span class="built_in">NSInvocation</span> * invocation = aspectInfo.originalInvocation;</span><br><span class="line">    [invocation setArgument:&amp;request atIndex:<span class="number">5</span>];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">&#125; error:&amp;error];</span><br></pre></td></tr></table></figure><p>这里边<code>aspectInfo</code>就是被hook方法的信息，可以通过它取到原方法的参数，调用对象等等，我们这里要添加我们的token，因此取出参数进行修改</p><ul><li>arguments是原方法的入参列表，是一个数组</li><li>invocation是一个消息对象，包含了一个方法的所有信息<br>通过<code>URLSession: task: willPerformHTTPRedirection: newRequest: completionHandler:</code>方法我们可以知道<code>request</code>的索引是3，<code>task</code>的索引是1（取出它是因为我们要获取原header信息，这个不能丢弃），之后对<code>request</code>重新进行赋值，完成修改，然后重新调用方法</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[invocation setArgument:&amp;request atIndex:<span class="number">5</span>];</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><p>因为我们只需要修改<code>request</code>一个对象，因此只重新设置这一个方法入参，至于这里为什么在赋值的时候索引是5,因为前两个分别被该方法的<code>self</code>与<code>_cmd</code>占用，所以我们设置参数的时候索引是从2开始</p><p>再次run，嗯，图片顺利加载，问题解决。</p><p>这样一来，我们就不需要修改三方的源码就解决了问题，否则修改源码的话每次更新<code>Pod</code>我们的修改就会被覆盖掉，如果哪次发版没注意，测试也没回归覆盖，很容易将问题带到线上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Round-1&quot;&gt;Round 1&lt;/h4&gt;
&lt;p&gt;最近公司的文件服务器进行了改造，即使是图片的加载请求也要携带&lt;code&gt;token&lt;/code&gt;，否则无法加载，而我们项目中图片加载用的是&lt;code&gt;SDWebImage&lt;/code&gt;,当时听到这个需求我内心毫无波</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://lazy.wiki/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>快进来找个地方坐下，一个移动端老菜鸟的2021年度总结</title>
    <link href="https://lazy.wiki/posts/9983e3c6/"/>
    <id>https://lazy.wiki/posts/9983e3c6/</id>
    <published>2021-12-19T08:12:09.000Z</published>
    <updated>2022-05-21T08:27:14.934Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong> 想一想，参加工作已经五年了，还从没有给自己写过年度总结（只写过公司要求的那种），最近在群里看到各位群友都在写年度总结，看了几篇后感觉挺有意思，字里行间的喜怒哀乐，让我感觉非常亲切，这就是生活的味道啊，所以，不自觉地就开始回想起自己这一年的经历，遂动手写下了了这篇自己人生中第一篇年度总结。</p><h2 id="回首2021">回首2021</h2><h3 id="工作">工作</h3><p>进入目前公司是在去年国庆节前后，当时项目紧，并且公司对那个项目也非常重视，所以我们几个移动端一一起参与进去加了一段时间的班，到去年底今年初的时候，公司启动了一个新项目，可能是因为我之前做过物流相关的项目，而这个也是物流相关，所以领导决定让我去做，其实项目挺简单，所以从我接下来到现在，一年时间平平淡淡，项目稳步迭代，也没有什么大的技术难点，这让我中间有了一段时间的空闲期，中间抽身到别的项目去做过一段辅助性工作，再然后还是没需求进来，工作不饱和，我就开始思考起干脆去看点新东西吧。</p><h3 id="学习">学习</h3><h4 id="Flutter">Flutter</h4><p>其实<code>flutter</code>这个跨平台框架发布已经有几年时间了，不过由于我没有认真去了解过，所以对于我来说是一个新的东西，以前看过几天，没有实际应用边学边忘，为了避免再次出现这样的情况于是我把公司的项目给仿写了下，</p><p>当时找了好多在线教程教程和书籍包括<a class="link"   href="https://book.flutterchina.club" >《Flutter实战》<i class="fas fa-external-link-alt"></i></a>以及在京东读书看的《Flutter入门与实战》</p><p>一开始确实不太习惯，从命令式布局的UIKit到声明式布局的Flutter，当时在写的时候脑海中不自觉地问了很多次为什么，这里为什么要这么写，那里为什么要这么设计，因为当时我的思维逻辑还是iOS里UIKit的布局方式那一套，特别是写列表的时候，查了很多次Flutter的列表复用的问题，再比如…这嵌套也太tm恶心了吧🤮，为什么非要一层一层嵌套，我就写个层叠布局为什么非要套一层…之类的问题很多，但是写的久了之后，写的顺手了后，我只想说一句</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfba9b2458c4400a8600321c2772d68c~tplv-k3u1fbpfcp-zoom-1.image"                      alt=""                ></p><p>大概断断续续看了一个月左右，把现在项目大体给仿写了一遍，就此，搬砖技能+1</p><p>在flutter看的基本能写项目后，本想在项目中应用下来写业务，但是调研了以native为基础的混合开发后发现，坑挺多的，业务闭环问题，路由问题，内存问题，包大小等等，和领导沟通后还是还是求稳为主，没有在项目中使用，但是那个仿写项目我还在继续。</p><h4 id="Vue">Vue</h4><p>大概在三四个月前，项目组有个需求比较重要且紧急，当时的前端同事在做了排期后提出时间可能有点紧，而我当时手头刚好没需求在开发，领导就找到我说要不也参与进来做一些辅助性工作（其实我们公司前端人数挺多的，但是分散在各个项目组，而我们项目组刚好这时资源不太够），听完后我心里一想，可以啊，反正我之前也看过jQuery，有一点点基础，而我自己也有兴趣，于是便参与了进去</p><p>公司前端项目用的是vue2.0，又是一波，文档，资料，看了后感觉，vue入门确实简单，很多东西都是现成的，直接用就好了，UI组件vant类似的库也是开箱即用，不像iOS，除了基本的组件什么都要自己搞，路由要自己搞，数据管理还复杂，就这么搞了大概两周，项目顺利上线，就此，搬砖技能+0.5（因为flutter起码我已经可以完整的写简单的项目了，而前端我只参与了其中的一个模块，不懂的东西茫茫多）</p><p>vue的学习必须要感谢一位<a class="link"   href="https://juejin.cn/post/7041494869855961118" >不愿意透漏姓名的老哥<i class="fas fa-external-link-alt"></i></a>，感谢老哥的无私帮助，感谢命运让我们相遇，感谢党和政府给予我们的幸福生活😂😂😂</p><h4 id="英语">英语</h4><p>啊，说起英语，学生时代就让我头痛，没想到毕业后还是要整天接触（真的是没想到，因为我非科班出身，毕业后在对口行业工作了半年后才参加培训转行开发）不过仅仅是开发的话其实对英语要求不高，想要进阶要求才高，毕竟很多文档，资料都是英文的.</p><p>我大概是在前一段时间，在YouTube看视频，看到下边评论，大多数都是英文评论，而我又想知道他们到底说的什么（我知道YouTube自带翻译），我开始尝试着去理解评论，发现只能看个大概，很多单词不认识，所以又萌生了去学英语的想法，我为什么要说又呢？因为之前几乎每年都有这样的想法，但是都没有实际行动，于是我上某乎搜索，学英语app，然后把推荐的七八款app全都下载，一个一个打开看哪个更好用（好看），最终选择了其中的四款，但其实是两家公司的产品，这里我不得不吐槽下，为什么现在都喜欢把一个需求的子需求单独做app，然后开不同的会员，对不同的会员，比如听力，一个app，单词，又一个app，文章阅读再搞一个app，然后每个app都有单独的会员，我屮艸芔茻，产品经理鬼才啊是吧，逮着羊毛使劲薅是吧…</p><p>但是吐槽归吐槽，该学还是要学，从基本的卖火柴的小女孩，阿拉丁神灯这些文章开始看起，每天再背点单词，到现在持续了差不多十天了，也不知道还能坚持几天，会不会像以前一样最后不了了之，总之先就这样吧，起码我目前没有放弃的想法…</p><h4 id="其他无关的书籍">其他无关的书籍</h4><ul><li><p>中间想填充下空虚的精神还看了几本杂书，因为以前很喜欢看雍正王朝电视剧，所以去看完了原著小说，雍正皇帝三部曲《九王夺嫡》《雕弓天狼》《恨水东逝》不得不说，电视拍的好，小说写得也棒；</p></li><li><p>另外今年微博爆出的几篇小作文，把男女性别矛盾推向了新的高峰，我一直觉得性别之上还有人性，我们应该骂的是恶人，而不是性别不同的人，恶人自有法律制裁，而你，只需要做好自己，所以我想知道微博女拳到底在想什么，所以我去看了《女性主义有什么用》希望能了解一二，不过暂时还没看完；</p></li><li><p>而我本人一直很喜欢看历史和自然相关的内容，以前在家整天看中央十套的《探索发现》《科技之光》《动物世界》之类的节目，书籍以前也看过一些，有一天突然在网上看到有人推荐《人类简史：从动物到上帝》，于是便找出来看了下，确实不错，虽然不讲具体的历史事件，但是会从历史进程去思考，更像是一本哲学书籍，目前也没看完，看了一部分，后续会接着继续看；</p></li></ul><h3 id="生活">生活</h3><p>今年，和谈了几年的女朋友也到了谈婚论嫁的地步，女朋友也来到了我工作的城市，围绕着订婚，三金，彩礼，车子等问题我们进行了坦率的沟通，充分交换了意见，进一步增进了双方的了解，顺利的订了婚。</p><p>这期间，我们也闹过矛盾，大多是因为一些很小的，很细微的问题，甚至是一个眼神，一个手势，这让我倍感无奈，有时候对于一件事，明明有性价比更高，更合理简单的处理方式，但是却不去选择更优解，这让我难以理解，而我，只能在一声叹气后走过去，抱住，安慰两句，静静的等情绪的平复，有时候会更严重些，一直闹到半夜，虽然最后我们都会和好如初，但是我还是想说一句，人生啊…</p><h2 id="展望2022">展望2022</h2><p>虽然是一个这么2的年份，我也有些许期待和计划…</p><ul><li><p>据传003要下水，期待满满，不知道有没有机会近距离去看看</p></li><li><p>继续我的英语学习计划</p></li><li><p>继续学习跨端以及前端技术</p></li><li><p>使用flutter开发一个商业级项目</p></li><li><p>看完五本书（太多怕打脸）</p></li><li><p>开始定期写文，以前也写但是随缘，可能半年一年才写一篇</p></li><li><p>体重重回62公斤</p></li><li><p>挣更多的小钱钱（这是最主要的）</p></li><li><p>中个500万吧不用太多😂</p></li></ul><h2 id="结语">结语</h2><p>最后，祝愿世界和平，祖国繁荣昌盛，疫情早日结束，各位事业进步，生活美满，风会指引你们前进的方向，大地母亲与你同在,Lok’Tar Ogar!!!🙏🙏🙏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt; 想一想，参加工作已经五年了，还从没有给自己写过年度总结（只写过公司要求的那种），最近在群里看到各位群友都在写年度总结，看了几篇后感觉挺有意思，字里行间的喜怒哀乐，让我感觉非常亲切，这就是生活的味道啊，所以，不自觉地就开始回想起自己这</summary>
      
    
    
    
    <category term="随笔" scheme="https://lazy.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="年终总结" scheme="https://lazy.wiki/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS模拟器推送测试及踩坑</title>
    <link href="https://lazy.wiki/posts/b766a676/"/>
    <id>https://lazy.wiki/posts/b766a676/</id>
    <published>2021-12-19T07:43:04.000Z</published>
    <updated>2022-05-21T08:27:14.930Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong> 现在的App几乎都有推送功能，开发推送功能的时候我们肯定要进行测试，但是之前推送功能只有在真机上才能测试，在<code>Xcode11.4</code>之后，模拟器也支持推送测试，具体操作如下：</p><h3 id="1-创建推送文件">1.创建推送文件</h3><p>内容类似如下格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot;:&#123;</span><br><span class="line">        &quot;alert&quot;:&#123;</span><br><span class="line">            &quot;title&quot;:&quot;标题&quot;,</span><br><span class="line">            &quot;body&quot;:&quot;内容辱与共产主义不容辞&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;content-available&quot; : 1,</span><br><span class="line">        &quot;mutable-content&quot; : 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体格式根据你们的产品要求，接入极光或者个推的可以在控制台发一条推送打印出具体格式内容查看,将文件保存后缀为<strong>apns</strong>，待会要用到</p><h3 id="2-执行如下命令进行测试">2.执行如下命令进行测试</h3><ol><li>查看已启动模拟器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl list devices | grep Booted</span><br></pre></td></tr></table></figure><p>会看到类似下面信息，如果没有请先启动模拟器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iPhone 12 Pro (1BEE4182-C934-431E-BCBF-F7676C4C2BFC) (Booted)</span><br></pre></td></tr></table></figure><ol start="2"><li>运行项目在模拟器上后执行相应命令<code>simctl push &lt;device&gt; [&lt;bundle identifier&gt;] (&lt;json file&gt; | -)</code></li></ol><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl push Booted com.app.test /Users/lazyloading/Desktop/payload.apns</span><br></pre></td></tr></table></figure><h3 id="3-另外还有一种方式是直接使用推送文件">3.另外还有一种方式是直接使用推送文件</h3><p>将第一步创建的json文件内容稍加修改,具体就是添加了<code>   &quot;Simulator Target Bundle&quot;: &quot;com.app.test&quot;你项目的包名</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Simulator Target Bundle&quot;: &quot;com.app.test&quot;,</span><br><span class="line">    &quot;aps&quot;:&#123;</span><br><span class="line">        &quot;alert&quot;:&#123;</span><br><span class="line">            &quot;title&quot;:&quot;标题&quot;,</span><br><span class="line">            &quot;body&quot;:&quot;内容辱与共产主义不容辞&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;content-available&quot; : 1,</span><br><span class="line">        &quot;mutable-content&quot; : 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接拖动文件到模拟器上，出现绿色➕后松手，这样也可以进行推送测试</p><h3 id="踩坑">踩坑</h3><p>到这里按照网上你查看的其他教程应该已经收到测试的推送了，但是我没有&gt;_&lt;!</p><p>原因很简单，没有注册，我的项目中集成的是极光推送，已经存在注册步骤，但是这里依然要我注册，如果你遇到类似的问题，添加如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UNUserNotificationCenter.currentNotificationCenter requestAuthorizationWithOptions:UNAuthorizationOptionAlert | UNAuthorizationOptionSound  completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%d&quot;,granted);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这是应该就可以正常收到推送了，但是依然存在几个问题，推送相关的代理方法没有执行，iOS15真机可以，模拟器不行，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler </span><br></pre></td></tr></table></figure><p>另外就是前台没法收到推送，退到后台才可以，至少我这里遇到的情况是这样，虽然模拟器支持推送测试，但是依然无法和真机进行比较，最好还是以真机测试为准</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt; 现在的App几乎都有推送功能，开发推送功能的时候我们肯定要进行测试，但是之前推送功能只有在真机上才能测试，在&lt;code&gt;Xcode11.4&lt;/code&gt;之后，模拟器也支持推送测试，具体操作如下：&lt;/p&gt;
&lt;h3 id=&quot;1-创建推送</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://lazy.wiki/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew 安装Mysql密码忘记解决</title>
    <link href="https://lazy.wiki/posts/ed9ccb24/"/>
    <id>https://lazy.wiki/posts/ed9ccb24/</id>
    <published>2021-12-19T07:40:17.000Z</published>
    <updated>2022-05-21T08:27:14.932Z</updated>
    
    <content type="html"><![CDATA[<p>我的Mac很久之前安装了mysql，当时设置了密码，最近重新想起来用，但是忘记了密码，网上找了很多文章，千篇一律几乎都是复制粘贴，个别过分的就贴一个链接完事，找了很久终于找到了解决方案，所以做个记录，免得遇到同样问题的人跟我一样找半天解决方案</p><h3 id="5-8及之前，网上文章几乎都是针对此种情况">5.8及之前，网上文章几乎都是针对此种情况</h3><p><strong>第一步</strong><br>因为忘记密码无法启动，所以执行下面命令进入安全启动模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start --skip-grant-tables</span><br></pre></td></tr></table></figure><p><strong>第二步</strong><br>登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot</span><br></pre></td></tr></table></figure><p><strong>第三步</strong><br>此时进入<code>mysql</code>下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure><p><strong>第四步</strong><br>接着执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES; </span><br></pre></td></tr></table></figure><p><strong>第五步</strong><br>设置密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;你的新密码&#x27;);</span><br></pre></td></tr></table></figure><p>退出mysql，杀掉进程，重新启动</p><h3 id="5-8之后，我的是8-0-25">5.8之后，我的是8.0.25</h3><p>前四步操作同上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER user &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;你的新密码&#x27;;</span><br></pre></td></tr></table></figure><p>退出mysql，杀掉进程，重新启动即可正常登陆</p><p><a class="link"   href="https://dev.mysql.com/doc/refman/8.0/en/resetting-permissions.html" >文档<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的Mac很久之前安装了mysql，当时设置了密码，最近重新想起来用，但是忘记了密码，网上找了很多文章，千篇一律几乎都是复制粘贴，个别过分的就贴一个链接完事，找了很久终于找到了解决方案，所以做个记录，免得遇到同样问题的人跟我一样找半天解决方案&lt;/p&gt;
&lt;h3 id=&quot;5-8</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Mysql" scheme="https://lazy.wiki/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>iOS15推送后台语音播报探索</title>
    <link href="https://lazy.wiki/posts/6fd361a9/"/>
    <id>https://lazy.wiki/posts/6fd361a9/</id>
    <published>2021-12-19T06:38:57.000Z</published>
    <updated>2022-05-21T08:27:14.930Z</updated>
    
    <content type="html"><![CDATA[<p>meta <meta name="referrer" content="no-referrer" /></p><h3 id="前言">前言</h3><p>前一段时间公司项目有个推送内容语音播报的需求，当时让做技术调研，简单搜了下相关的文章和资料，调研一半的时候突然来了优先级更高的需求，搁置了，这两天空下来，所以继续看，并且有了可行的方案。</p><p>调研后发现这个需求用到<strong>Notification Service Extension</strong>，网上有一些文章讲这个需求的实现，但是绝大多数讲的方案现在已经不适用了或者是只提供一个大致的思路没有具体的实现，所以把我实现这个需求的过程记录分享出来</p><h3 id="Notification-Service-Extension">Notification Service Extension</h3><p><code>Notification Service Extension</code>iOS10之后才能使用，如果要想使用<code>Notification Service Extension</code>对通知内容进行更改，需要在推送中增加<code>mutable-content</code>字段并将值设置为<code>true</code>，使用通知扩展后推送的处理流程如图所示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-0078503af33c455b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="image"                ><br>创建步骤如下图所示<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-f1a6486c00c4936f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="image"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-2438899df962bf8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="image"                ></p><p>完成后会在项目中生成一个target和对应的文件夹，我们的代码就要卸载<code>NotificationService.m</code>中</p><p><code>NotificationService.m</code>文件内部有两个方法，我们可以在这个方法中对通知内容进行修改</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call contentHandler with the modified notification content to deliver. If the handler is not called before the service&#x27;s time expires then the unmodified notification will be delivered.</span></span><br><span class="line"><span class="comment">// You are expected to override this method to implement push notification modification.</span></span><br><span class="line">- (<span class="type">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="type">void</span> (^)(UNNotificationContent *contentToDeliver))contentHandler</span><br></pre></td></tr></table></figure><p>在这个方法中做通知扩展终止前的兜底处理</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Will be called just before this extension is terminated by the system. You may choose whether to override this method.</span></span><br><span class="line">- (<span class="type">void</span>)serviceExtensionTimeWillExpire;</span><br></pre></td></tr></table></figure><p>到此<code>Notification Service Extension</code>创建完成</p><h3 id="播报探索">播报探索</h3><h4 id="系统语音合成">系统语音合成</h4><p>系统提供的有文字转语音播报的方法，我们在收到推送后可以传入文字直接播报出语音</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="type">void</span> (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</span><br><span class="line">    <span class="keyword">self</span>.contentHandler = contentHandler;</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent = [request.content mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Modify the notification content here...</span></span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent.title = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ [modified]&quot;</span>, <span class="keyword">self</span>.bestAttemptContent.title];</span><br><span class="line">    <span class="built_in">NSString</span> *content = <span class="keyword">self</span>.bestAttemptContent.userInfo[<span class="string">@&quot;aps&quot;</span>][<span class="string">@&quot;alert&quot;</span>][<span class="string">@&quot;body&quot;</span>];</span><br><span class="line">    <span class="built_in">AVSpeechUtterance</span> *utterance = [<span class="built_in">AVSpeechUtterance</span> speechUtteranceWithString:content];</span><br><span class="line">    <span class="built_in">AVSpeechSynthesisVoice</span> *voice = [<span class="built_in">AVSpeechSynthesisVoice</span> voiceWithLanguage:<span class="string">@&quot;zh-CN&quot;</span>];</span><br><span class="line">    utterance.voice = voice;</span><br><span class="line">    <span class="built_in">AVSpeechSynthesizer</span> *synth = [[<span class="built_in">AVSpeechSynthesizer</span> alloc] init];</span><br><span class="line">    [synth speakUtterance:utterance];</span><br><span class="line">    <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上大部分文章也会这么写，但是现在实际应用中基本不会用这个方案原因有两个：</p><ol><li><strong>iOS12.1</strong>之后系统限制了在扩展里进行播报的能力，所以此方案只能用在<strong>iOS12.1</strong>之前</li><li>语音生硬，并且多音字和英文字母在汉语语境下经常读错，比如字母<code>E</code>会读成<code>额</code>的音(这个我同一套代码在不同设备上读音不一致，没找到原因)，还是三方服务效果好点&gt;_&lt;!</li></ol><h4 id="内置本地音频">内置本地音频</h4><p>后来就想，不能语音合成，那播放本地语音呢？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="type">void</span> (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</span><br><span class="line">    <span class="keyword">self</span>.contentHandler = contentHandler;</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent = [request.content mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Modify the notification content here...</span></span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent.title = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ [modified]&quot;</span>, <span class="keyword">self</span>.bestAttemptContent.title];</span><br><span class="line">    <span class="built_in">NSString</span> * voiceType = <span class="keyword">self</span>.bestAttemptContent.userInfo[<span class="string">@&quot;voiceType&quot;</span>];</span><br><span class="line">    UNNotificationSound * sound = [UNNotificationSound soundNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@.mp3&quot;</span>,voiceType]];</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent.sound = sound;</span><br><span class="line">    <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展类中有个<code>bestAttemptContent</code>属性，他是<code>UNMutableNotificationContent</code>类型，我们在修改推送内容时也是对它进行修改，而播放本地语音就是修改它的<code>sound</code>属性，但是这个时候产品跳出来了，说对这样的实现不太满意，太死板，只能播放固定的音频不够灵活😂，没办法只能继续看</p><p>然后就想把播报内容拆开，本地内置几段语音，根据推送内容进行拼接，然后修改<code>sound</code>进行播报，我先随便找了两段比较短的音频内置进项目进行测试</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)audioMergeClick&#123;</span><br><span class="line">    <span class="comment">//1.获取本地音频素材</span></span><br><span class="line">    <span class="built_in">NSString</span> *audioPath1 = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@&quot;1&quot;</span> ofType:<span class="string">@&quot;mp3&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *audioPath2 = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@&quot;2&quot;</span> ofType:<span class="string">@&quot;mp3&quot;</span>];</span><br><span class="line">    <span class="built_in">AVURLAsset</span> *audioAsset1 = [<span class="built_in">AVURLAsset</span> assetWithURL:[<span class="built_in">NSURL</span> fileURLWithPath:audioPath1]];</span><br><span class="line">    <span class="built_in">AVURLAsset</span> *audioAsset2 = [<span class="built_in">AVURLAsset</span> assetWithURL:[<span class="built_in">NSURL</span> fileURLWithPath:audioPath2]];</span><br><span class="line">    <span class="comment">//2.创建两个音频轨道,并获取两个音频素材的轨道</span></span><br><span class="line">    <span class="built_in">AVMutableComposition</span> *composition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line">    <span class="comment">//音频轨道</span></span><br><span class="line">    <span class="built_in">AVMutableCompositionTrack</span> *audioTrack1 = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">AVMutableCompositionTrack</span> *audioTrack2 = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//获取音频素材轨道</span></span><br><span class="line">    <span class="built_in">AVAssetTrack</span> *audioAssetTrack1 = [[audioAsset1 tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] firstObject];</span><br><span class="line">    <span class="built_in">AVAssetTrack</span> *audioAssetTrack2 = [[audioAsset2 tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>]firstObject];</span><br><span class="line">    <span class="comment">//3.将两段音频插入音轨文件,进行合并</span></span><br><span class="line">    <span class="comment">//音频合并- 插入音轨文件</span></span><br><span class="line">    <span class="comment">// `startTime`参数要设置为第一段音频的时长，即`audioAsset1.duration`, 表示将第二段音频插入到第一段音频的尾部。</span></span><br><span class="line">    </span><br><span class="line">    [audioTrack1 insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, audioAsset1.duration) ofTrack:audioAssetTrack1 atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line">    [audioTrack2 insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, audioAsset2.duration) ofTrack:audioAssetTrack2 atTime:audioAsset1.duration error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//4. 导出合并后的音频文件</span></span><br><span class="line">    <span class="comment">//`presetName`要和之后的`session.outputFileType`相对应</span></span><br><span class="line">    <span class="comment">//音频文件目前只找到支持m4a 类型的</span></span><br><span class="line">    <span class="built_in">AVAssetExportSession</span> *session = [[<span class="built_in">AVAssetExportSession</span> alloc]initWithAsset:composition presetName:<span class="built_in">AVAssetExportPresetAppleM4A</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *outPutFilePath = [[<span class="keyword">self</span>.filePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:<span class="string">@&quot;test.m4a&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:outPutFilePath]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:outPutFilePath error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看当前session支持的fileType类型</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;---%@&quot;</span>,[session supportedFileTypes]);</span><br><span class="line">    session.outputURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.filePath];</span><br><span class="line">    session.outputFileType = <span class="built_in">AVFileTypeAppleM4A</span>; <span class="comment">//与上述的`present`相对应</span></span><br><span class="line">    session.shouldOptimizeForNetworkUse = <span class="literal">YES</span>;   <span class="comment">//优化网络</span></span><br><span class="line">    [session exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">        <span class="keyword">if</span> (session.status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;合并成功----%@&quot;</span>, outPutFilePath);</span><br><span class="line">            UNNotificationSound * sound = [UNNotificationSound soundNamed:<span class="string">@&quot;test.m4a&quot;</span>];</span><br><span class="line">            <span class="keyword">self</span>.bestAttemptContent.sound = sound;</span><br><span class="line">            <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，推送过来后播报的还是默认声音😳，于是开始找原因，一开始以为是文件格式的问题，于是把<code>m4a</code>转化成<code>mp3</code>(省略代码)，还是不行，最后找到了一片文章（感谢大佬），文章说<code>sound</code>读取本地音频不是所有路径都可以，是有优先级的</p><ol><li>主应用中的文件夹</li><li>AppGroups共享目录中的Library/Sounds文件夹</li><li>main bundle</li></ol><p>根据这个说法我开始测试，首先是第一条，我打印出APP沙盒<code>Library</code>下所有目录</p><ul><li>Library/Sounds<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-c3802d151760f3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="image"                ><br>看到里边的<code>Sounds</code>目录了吧，这是我创建的，之前并没有，然后修改合成文件的保存路径，重新走起！</li></ul><p>额，依然播报的是系统默认声音，短时间内没找到原因，于是直接看第二优先级</p><ul><li>AppGroups</li></ul><p>我们知道因为沙盒机制，iOS系统的App只能访问自己的文件夹，<code>AppGroups</code>就是苹果提供的同一开发者账号下多App资源共享的一种方案，最低支持<code>iOS8</code>，我们用的是企业签名，因为公司组织架构和权限的原因麻烦了一天才把一个简单<code>AppGroups</code>配置完成😭，这里就不贴具体的创建和配置过程了，网上相关的资料也很多了</p><p>最终将上边的音频文件导出路径修改为<code>AppGroups</code>下的<code>Library/Sounds</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[session exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">    <span class="keyword">if</span> (session.status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;合并成功----%@&quot;</span>, outPutFilePath);</span><br><span class="line">        UNNotificationSound * sound = [UNNotificationSound soundNamed:<span class="string">@&quot;test.m4a&quot;</span>];</span><br><span class="line">        <span class="keyword">self</span>.bestAttemptContent.sound = sound;</span><br><span class="line">        <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>记得判断文件夹是否存在，我这里简单贴一下<code>AppGroups</code>的操作吧</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *groupURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:kGroupDefaultSuiteName];</span><br><span class="line">    <span class="built_in">NSURL</span> * sounds = [groupURL URLByAppendingPathComponent:<span class="string">@&quot;/Library/Sounds/&quot;</span> isDirectory:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:sounds.path error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] createDirectoryAtPath:sounds.path withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终，发起推送，播报成功，但这个方案产品虽然说可以但还是不太满意，于是，继续摸索</p><h3 id="最终方案">最终方案</h3><p>那么总结下之前方案不行的原因：</p><ul><li>直接语音转文字播报，系统限制iOS12.1后播报能力</li><li>固定音频，不够灵活产品不满意</li><li>拆分固定音频，拼接后播报（同上）</li></ul><p>既然这样，能不能把上边几种方案的优点结合下？将文字转语音后的音频文件存到本地然后再去播报？这里得到了另一个大佬的指点（感谢大佬），尝试过后确认方案可行☺️</p><p>查看了<code>AVSpeechSynthesizer</code>文档后没找到转音频文件的相关方法（可能是我眼拙，找到的请告诉我）于是去看了三方的能力，其中百度和科大讯飞的离线合成都提供了获取音频文件的方法，但是最终我用的是科大讯飞的，因为百度的只提供两个设备码供测试，科大讯飞的十个（格局打开）</p><p>详细方法看<a class="link"   href="https://www.xfyun.cn/doc/tts/offline_tts/iOS-SDK.html#_3%E3%80%81%E5%9C%A8%E7%BA%BF%E5%90%88%E6%88%90" >科大讯飞<i class="fas fa-external-link-alt"></i></a>文档，注册申请过程我这里就不赘述了，但是如果想用三方服务强烈建议先看文档！！！</p><h5 id="1-初始化离线合成引擎">1. 初始化离线合成引擎</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//讯飞</span></span><br><span class="line">  [IFlySetting setLogFile:LVL_ALL];</span><br><span class="line">  [IFlySetting showLogcat:<span class="literal">YES</span>];</span><br><span class="line">  <span class="built_in">NSString</span> *initString = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;appid=%@&quot;</span>, <span class="string">@&quot;你的appid&quot;</span>];</span><br><span class="line">  [IFlySpeechUtility createUtility:initString];</span><br></pre></td></tr></table></figure><h5 id="2-设置参数">2. 设置参数</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_iFlySpeechSynthesizer = [IFlySpeechSynthesizer sharedInstance];</span><br><span class="line">  _iFlySpeechSynthesizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">  [[IFlySpeechUtility getUtility] setParameter:<span class="string">@&quot;tts&quot;</span> forKey:[IFlyResourceUtil ENGINE_START]];</span><br><span class="line">  <span class="comment">//设置本地引擎类型，普通版设置为TYPE_LOCAL，高品质版设置为TYPE_LOCAL_XTTS</span></span><br><span class="line">  [_iFlySpeechSynthesizer setParameter:[IFlySpeechConstant TYPE_LOCAL] forKey:[IFlySpeechConstant ENGINE_TYPE]];</span><br><span class="line">  <span class="comment">//设置发音人为小燕</span></span><br><span class="line">  [_iFlySpeechSynthesizer setParameter:<span class="string">@&quot;xiaoyan&quot;</span> forKey:[IFlySpeechConstant VOICE_NAME]];</span><br><span class="line">  <span class="comment">//获取离线语音合成发音人资源文件路径。以发音人小燕为例，请确保资源文件的存在。</span></span><br><span class="line">  <span class="built_in">NSString</span> *resPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;common&quot;</span> ofType:<span class="string">@&quot;jet&quot;</span>];</span><br><span class="line">  <span class="built_in">NSString</span> *resPath1 = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;xiaoyan&quot;</span> ofType:<span class="string">@&quot;jet&quot;</span>];</span><br><span class="line">  <span class="built_in">NSString</span> *vcnResPath = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@&quot;%@;%@&quot;</span>,resPath,resPath1];</span><br><span class="line">  <span class="comment">//设置离线语音合成发音人资源文件路径</span></span><br><span class="line">  [_iFlySpeechSynthesizer setParameter:vcnResPath forKey:<span class="string">@&quot;tts_res_path&quot;</span>];</span><br><span class="line">  [_iFlySpeechSynthesizer synthesize:content toUri:[<span class="keyword">self</span> pcmPath]];</span><br></pre></td></tr></table></figure><p>其中<code>-(void)synthesize:(NSString *)text toUri:(NSString*)uri</code>方法就是离线合成后讲语音文件保存本地的方法，两个参数，第一个是要播报的文字内容，第二个是音频文件要存储的路径</p><h5 id="3-获取本地音频">3. 获取本地音频</h5><p>这边有个问题就是离线合成的语音文件是<code>pcm</code>格式的，不仅是讯飞，百度也是一样，<code>pcm</code>我们是不能直接给<code>sound</code>播放的，所以我们要做一个格式转换，转成<code>mp3</code>进行播放，贴一个pcm转mp3方法，需要用的<code>lame</code>三方库</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * pcm 文件转mp3文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)convertPcm:(<span class="built_in">NSString</span> *)pcmPath toMp3:(<span class="built_in">NSString</span> *)mp3Path &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        FILE *fpcm = fopen([pcmPath cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fpcm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        fseek(fpcm, 1024*4, SEEK_CUR); //跳过源文件的信息头，不然在开头会有爆破音</span></span><br><span class="line">        FILE *fmp3 = fopen([mp3Path cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> channelCount = <span class="number">1</span>;   <span class="comment">// 声道数, 跟录音时配置一样的</span></span><br><span class="line">        lame_t lame = lame_init();</span><br><span class="line">        lame_set_in_samplerate(lame, <span class="number">16000</span>); <span class="comment">//设置采样率, 需要跟录音时的采样率相同</span></span><br><span class="line">        lame_set_num_channels(lame, channelCount); <span class="comment">//声道，不设置默认为双声道</span></span><br><span class="line">        lame_set_VBR(lame, vbr_default);</span><br><span class="line"><span class="comment">//        lame_set_mode(lame, 0);//设置最终mp3编码输出的声道模式，如果不设置则和输入声道数一样。参数是枚举，STEREO代表双声道，MONO代表单声道</span></span><br><span class="line">        lame_set_quality(lame, <span class="number">2</span>);<span class="comment">//设置压缩品质，quality=0..9. 0=best (very slow). 9=worst. 品质越好转码速度越慢</span></span><br><span class="line">        lame_init_params(lame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="type">int</span> PCM_SIZE = <span class="number">8192</span>;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">const</span> <span class="type">int</span> <span class="built_in">MP3_SIZE</span> = <span class="number">8192</span>; <span class="comment">//</span></span><br><span class="line">        <span class="type">short</span> <span class="type">int</span> pcm_buffer[PCM_SIZE*channelCount];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> mp3_buffer[<span class="built_in">MP3_SIZE</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="type">int</span> write;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            read = fread(pcm_buffer, channelCount*<span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>), PCM_SIZE, fpcm);</span><br><span class="line">            <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                write = lame_encode_flush(lame, mp3_buffer, <span class="built_in">MP3_SIZE</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (channelCount == <span class="number">1</span>) &#123;</span><br><span class="line">                    write = lame_encode_buffer(lame, pcm_buffer, <span class="literal">NULL</span>, read, mp3_buffer, <span class="built_in">MP3_SIZE</span>); <span class="comment">// 单声道音频转码</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, <span class="built_in">MP3_SIZE</span>); <span class="comment">// 多声道音频转码</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fwrite(mp3_buffer, write, <span class="number">1</span>, fmp3);</span><br><span class="line">        &#125; <span class="keyword">while</span> (read != <span class="number">0</span>);</span><br><span class="line">        lame_mp3_tags_fid(lame, fmp3);</span><br><span class="line">        lame_close(lame);</span><br><span class="line">        fclose(fmp3);</span><br><span class="line">        fclose(fpcm);</span><br><span class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;catch exception, %@&quot;</span>, exception);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">@finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在合成完成方法中做转换和播报处理</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>) onCompleted:(IFlySpeechError *) error &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.errorCode == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *groupURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:kGroupDefaultSuiteName];</span><br><span class="line">        <span class="built_in">NSURL</span> * sounds = [groupURL URLByAppendingPathComponent:<span class="string">@&quot;/Library/Sounds/&quot;</span> isDirectory:<span class="literal">YES</span>];</span><br><span class="line">        <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:sounds.path error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] createDirectoryAtPath:sounds.path withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSURL</span> *mp3Path = [groupURL URLByAppendingPathComponent:<span class="string">@&quot;Library/Sounds/voice.mp3&quot;</span> isDirectory:<span class="literal">NO</span>];</span><br><span class="line">        <span class="type">BOOL</span> result = [<span class="keyword">self</span> convertPcm:[<span class="keyword">self</span> pcmPath] toMp3:mp3Path.path];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">if</span> (@available(iOS <span class="number">12.1</span>,*)) &#123;</span><br><span class="line">                UNNotificationSound * sound = [UNNotificationSound soundNamed:<span class="string">@&quot;voice.mp3&quot;</span>];</span><br><span class="line">                <span class="keyword">self</span>.bestAttemptContent.sound = sound;</span><br><span class="line">                <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                _player = [[<span class="built_in">AVAudioPlayer</span> alloc] initWithContentsOfURL:mp3Path error:<span class="literal">nil</span>];</span><br><span class="line">                [_player play];</span><br><span class="line">                <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里依然做了系统区分，因为实际测试后发现，iOS11的系统设置合成音频给<code>sound</code>后还是播放的默认声音，后来发现有人遇到类似的问题，iOS10-iOS12系统无法在推送扩展里读取到<code>AppGroups</code>中的音频文件，之前手边只有iOS15系统的测试机，没有发现这个问题，所以最后在依然做了区分处理低版本系统用<code>AVAudioPlayer</code>播放合成音频</p><h3 id="实现总结">实现总结</h3><ol><li>创建<code>Notification Service Extension</code>以实现对推送消息做最后的修改</li><li>添加<code>AppGroup</code></li><li>将要播报的文字内容用离线合成转成音频文件并存入<code>AppGroup</code>内的<code>/Library/Sounds</code>下</li><li>修改<code>bestAttemptContent</code>的<code>sound</code>为存入本地的音频文件</li></ol><p>虽然实现这个需求废了些时间，但是实现后回头看看，也就几步😂😂😂</p><h3 id="注意点">注意点</h3><ul><li><code>Extension</code>是单独的进程，离线合成引擎要在<code>Extension</code>中启动</li><li><code>Extension</code>启动后只有约30s时间供你操作，超时会播放默认声音</li><li>推送内容要添加<code>mutable-content</code>字段并将值设置为<code>true</code></li></ul><h3 id="参考文章">参考文章</h3><p><a class="link"   href="https://juejin.cn/post/7026905121866924063" >iOS小技能：消息推送扩展的使用<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://juejin.cn/post/6844904042515152903" >iOS13微信收款到账语音提醒开发总结<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;meta &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;前一段时间公司项目有个推送内容语音播报的需求，当时让做技术调研，简单搜了下相关的文章和资料，调研一半的时候突然来了优</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="https://lazy.wiki/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初识Flutter总结</title>
    <link href="https://lazy.wiki/posts/9bd452f5/"/>
    <id>https://lazy.wiki/posts/9bd452f5/</id>
    <published>2021-07-22T14:33:55.000Z</published>
    <updated>2022-05-21T08:27:14.927Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />[toc]<h2 id="Flutter是什么">Flutter是什么</h2><ul><li>Flutter是一个基于<code>Dart</code>语言的跨平台<strong>UI</strong>框架，目前支持的平台有<code>iOS</code>，<code>android</code>，<code>Web</code>，<code>Mac OS</code>，<code>Windows</code>，<code>Linux</code>，强调这个是因为有部分初学者没接触的时候认为Flutter是一门语言，这是不正确的</li></ul><h2 id="环境搭建">环境搭建</h2><ul><li>Mac和Linux系统设备建议使用<a class="link"   href="https://brew.sh/index_zh-cn" >Homebrew<i class="fas fa-external-link-alt"></i></a>执行如下命令安装，Windows的话，去看教程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flutter</span><br></pre></td></tr></table></figure><ul><li>安装完默认路径一般为<code>/usr/local/Caskroom/flutter/2.2.0/flutter</code>这个样子</li><li>网上有一大堆的教程去叫你怎么搭建环境，这里重复的原因是因为，如果你去按照网上的教程去搭建环境，会感觉，很繁琐，真的很繁琐，特别是iOS开发人员，为什么搭建环境一定要那么多步骤？而Homebrew让这一切变得很简单，只需要一行命令，然后等待网络下载完成就是了</li></ul><h2 id="平台支持">平台支持</h2><ul><li>已Android studio为例，创建项目时，默认支持iOS和Android，但是可勾选支持Web，Linux和Windows ，Mac OS为不可选，如果需要支持可手动进行配置，命令如下，之后再创建项目就可以勾选相应的其他平台</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-windows-desktop</span><br><span class="line">flutter config --enable-macos-desktop</span><br><span class="line">flutter config --enable-linux-desktop</span><br></pre></td></tr></table></figure><ul><li>如果想要在已有的项目中添加新的平台，进入项目根目录后执行如下命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create .</span><br></pre></td></tr></table></figure><h2 id="组件">组件</h2><h3 id="概括">概括</h3><ul><li><p>Flutter里的组件都是Widget，基本可以分为两大类<code>StatefulWidget</code>（可变）和<code>StatelessWidget</code>（不可变）,区别就在于前者可以通过对应的State类去改变内容，所以每一个StatefulWidget都要对应一个State，而后者初始化后就不能再进行改变</p></li><li><p>Flutter框架本身的组件风格分为两种<code>Material</code>和<code>Cupertino</code>，前者是Google的设计风格，看一下安卓设备大概就能了解到是什么样子，后者是iOS风格也就是Apple的设计风格，网上的教程几乎都是以<code>Material</code>，我在学习的过程中也是使用<code>Material</code>风格的组件，不过这些只是Flutter内置的供你使用的组件，同一个UI你完全可以用这两种风格分别实现</p></li></ul><h3 id="常用Widget">常用Widget</h3><p>Flutter中内置了几百个Widget，包含显示类的文字(Text)，图片(Image)等，也包含不直接显示的容器类Container，Row，Column等，当你入门后，对Flutter有了一定的认知，后续的使用中就是经验的积累，去识记更多的Widget，记得越多，开发越快，下面介绍几种常用的Widget，记住这几个后基本开发一个简单的App就没什么问题了</p><ol><li><p><strong>MaterialApp：</strong> 一般用作根Widget，App启动后，main（入口）函数中执行的方法中需要提供</p></li><li><p><strong>Scaffold：</strong> 顾名思义，他是Flutter提供的一个脚手架Widget，自带抽屉，导航等，方便你快速搭起App的结构</p></li></ol><ul><li><strong>Container：</strong> 容器类Widget的一种，也是最常用的Widget之一，可以理解为iOS中的UIView</li><li><strong>Row：</strong> 横向布局容器，加入其中的子Widget会水平排列布局</li><li><strong>Column：</strong> 纵向布局容器，加入其中的子Widget会纵向排列布局</li><li><strong>Stack：</strong> 叠加布局布局容器，加入其中的子Widget会叠加起来排列布局</li><li><strong>ListView：</strong> 市面上几乎所有的App都会使用的，列表Widget</li><li><strong>GridView：</strong> 卡片，瀑布流布局</li><li><strong>Text：</strong> 文字展示</li><li><strong>Image：</strong> 图片展示</li><li><strong>TextButton：</strong> 文字按钮</li><li><strong>GestureDetector：</strong> 如果某个Widget想要响应点击等交互事件，即使它本身不具备交互功能，只要用此Widget包括就可以了</li></ul><p><strong>示例：</strong><br><a href="https://imgtu.com/i/W0q3Ss"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-c74109cf6db91e49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="效果"                ></a><br>上面这样的一个布局，觉得是怎样实现的?</p><p><a href="https://imgtu.com/i/W0qs61"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-a4ad346ecbc02782.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="结构"                ></a><br>结构是这个样子的<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-68609f3a7c8cd261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="层级"                ></p><p>层级是这个样子的</p><h2 id="响应式">响应式</h2><ul><li><p>在iOS中，iOS的框架本身是不支持响应式编程的，如果需要，则要借助第三方框架，比如OC的RAC，Swift的RxSwift等，这些框架由于不是官方提供，只是社区为了实现响应式而基于官方框架开发的应用框架，有相当高的额外学习成本</p></li><li><p>而Flutter本身就是支持响应式的，这为我们的开发提供的很大的便利</p></li></ul><h2 id="原生交互">原生交互</h2><p>通过前面的介绍我么你知道Flutter本身是一个UI框架，如果涉及到一些非UI的比如相机拍照，必须要和Native交互调用硬件能力，那我们就必须和Native进行通信，Flutter中提供了三种通信方式</p><ol><li><p><strong>MethodChannel：</strong> Flutter 与 Native 端相互调用，调用后可以返回结果，可以 Native 端主动调用，也可以Flutter主动调用，属于双向通信。此方式为最常用的方式， Native 端调用需要在主线程中执行。</p></li><li><p><strong>BasicMessageChannel：</strong> 用于使用指定的编解码器对消息进行编码和解码，属于双向通信，可以 Native 端主动调用，也可以Flutter主动调用。</p></li><li><p><strong>EventChannel：</strong> 用于数据流（event streams）的通信， Native 端主动发送数据给 Flutter，通常用于状态的监听，比如网络变化、传感器数据等。</p></li></ol><p><strong>MethodChannel示例：</strong><br>Flutter端</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Flutter端 初始化消息通道</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel = <span class="keyword">const</span> MethodChannel(<span class="string">&#x27;com.methodChannel&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Flutter调用</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span> test = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">&#x27;methodChannelSend&#x27;</span>);</span><br></pre></td></tr></table></figure><p>iOS端</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swift端 初始化消息通道</span></span><br><span class="line">    <span class="keyword">let</span> channel <span class="operator">=</span> <span class="type">FlutterMethodChannel</span>(name: <span class="string">&quot;com.methodChannel&quot;</span>, binaryMessenger: registrar.messenger())</span><br><span class="line">    </span><br><span class="line"><span class="comment">//swift端 接收消息</span></span><br><span class="line">channel.setMethodCallHandler &#123; [<span class="keyword">weak</span> vc](call,  result) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> call.method <span class="operator">==</span> <span class="string">&quot;methodChannelSend&quot;</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;flutter给native发消息<span class="subst">\(call.arguments <span class="operator">??</span> (<span class="keyword">Any</span>).<span class="keyword">self</span>)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="库和插件">库和插件</h2><p>Flutter是一个UI框架，但是一个完整的App不只有UI展示，还有其他的能力，比如上边提到的硬件调用，录音，定位，网络请求，状态管理，数据持久化等等…这些能力中Flutter本身是不提供支持的，但是我们我们可以借助响应的库来实现，首先说一下库和插件的关系</p><ul><li><p>库是提供特定能力的开发工具包，可以是官方提供，也可以是三方提供</p></li><li><p>插件是特殊的库，举个例子，比如仅提供iOS和Android调用的库，要知道Flutter支持的平台不止这两个</p></li></ul><p>引入库和插件需要在Flutter项目中的<code>pubspec.yaml</code>中进行配置，下面提供一个我的配置截图：<br><a href="https://imgtu.com/i/W0LKnx"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-71d51f9ca94b6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="W0LKnx.png"                ></a></p><p>这里要注意<code>dev_dependencies</code>和<code>dependencies</code>两者的区别，前者指的是，只在开发阶段生效，不参与编译的库，后者指的是，参与编译，运行需要依赖的库，他们是有区别的，举个例子<code>build_runner</code>,<code>json_serializable</code>配合使用的话，可以通过注解，结合如下命令，生成额外的<code>xxx.g.dart</code>文件来帮助我们快速的生成JSON转Model方法，但是<code>xxx.g.dart</code>这个文件只在开发过程中生成和更新，这个库的作用也仅仅是生产这个文件，所以<code>build_runner</code>它本身不参与编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure><p>虽然都写在<code>dependencies</code>中项目也可以正常运行，但是这样的话打出来的包就会变得大一点，可以，但没必要</p><p>下面举例一些开发常用的库:</p><ul><li><code>dio</code> 三方网络库</li><li><code>webview_flutter</code>官方维护的webview库</li><li><code>cached_network_image</code>图片加载库</li><li><code>sqflite</code>基于sqlite的轻量级数据库框架</li><li><code>pull_to_refresh</code>下拉刷新上拉加载</li><li><code>shared_preferences</code>本地数据存储，适合少量数据</li></ul><h2 id="图片资源">图片资源</h2><ul><li>我们在开发过程中不免要导入一些静态资源，比如图片，文本文件，音频文件等，我目前只用到了图片资源这里也只介绍图片资源的导入和使用，下面看一下我的图片引入截图，同样是在<code>pubspec.yaml</code></li></ul><p><a href="https://imgtu.com/i/W0LRuq"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://upload-images.jianshu.io/upload_images/2334192-21710e0666ce8475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"                      alt="W0LRuq.png"                ></a><br>注意<code>pubspec.yaml</code>文件有着严格的格式要求，对齐有问题都会导致你导入失败，我当时就吃了系统模板的亏</p><h2 id="混编">混编</h2><p>以上介绍的都是纯Flutter项目，什么意思，就是说整个项目的主体是Flutter编写，可能部分功能涉及到和Native交互，但是实际上，很多成熟的项目想要体验Flutter，但是又不敢将整个项目使用Flutter重构，毕竟这中间是有很大风险的，所以我们可以在原生项目中，引入Futter模块，将Native中的某个小模块用Flutter开发来进行体验，这样做的风险我们是可以接受的，下面举一个iOS和Flutter混编并用cocoapods引入的示例</p><ul><li>假设<code>fluttermoduledemo</code>是一个iOS原生项目</li></ul><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/进入到fluttermoduledemo目录的上一级，执行如下命令</span></span><br><span class="line"><span class="regexp">flutter create --template module flutter_module</span></span><br></pre></td></tr></table></figure><ul><li><p>其中<code>flutter_module</code>为需要导入iOS的Flutter模块名称，这个模块的目录结构和纯Fluter项目的结构几乎一样，只不过有几个文件夹变成了隐藏文件夹，编写Flutter代码和在纯Flutter项目中没有区别</p></li><li><p>下面来看一下iOS项目如何引入</p></li></ul><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/在iOS项目的Podfile文件中添加如下配置，其中第一行最后的flutter_module，就是上一步创建的Flutter模块的名称</span></span><br><span class="line"><span class="regexp">  flutter_application_path = &#x27;../flutter</span>_module<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  load File.join(flutter_application_path,&quot;.ios&quot;,&quot;Flutter&quot;,&quot;podhelper.rb&quot;)</span></span><br><span class="line"><span class="string">  install_all_flutter_pods(flutter_application_path);</span></span><br></pre></td></tr></table></figure><ul><li>iOS使用</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//在Delegate中初始化Flutter引擎</span></span><br><span class="line"> <span class="keyword">lazy</span> <span class="keyword">var</span> flutterEngine <span class="operator">=</span> <span class="type">FlutterEngine</span>(name: <span class="string">&quot;ZMEngine&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="type">UIApplication</span>.<span class="params">LaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">     flutterEngine.run()</span><br><span class="line">     <span class="type">GeneratedPluginRegistrant</span>.register(with: <span class="keyword">self</span>.flutterEngine);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//在需要的地方，跳转Flutter模块</span></span><br><span class="line"><span class="keyword">let</span> vc <span class="operator">=</span> <span class="type">FlutterViewController</span>(engine:<span class="keyword">self</span>.flutterEngine, nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>) </span><br><span class="line"><span class="keyword">self</span>.present(vc,animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="未完内容">未完内容</h2><ul><li>另外还有一些内容也很重要，但是我这里没有展开说的原因是因为，我现在自己也没有搞得很明白，仅仅处于会用的阶段，比如<code>Future</code>涉及到Dart的线程机制，比如<code>状态管理</code>等，我听过一句话<code>唯有深入，才能浅出</code>，而现今我还没有非常深入，所以干脆就不讲，以免误人子弟，只做一个印象级概括</li></ul><h2 id="学习参考文档">学习参考文档</h2><p><a class="link"   href="https://flutterchina.club" >Flutter学习文档<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://dart.cn/samples" >Dart学习文档<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://pub.flutter-io.cn" >Flutter Package<i class="fas fa-external-link-alt"></i></a></p><h2 id="结尾">结尾</h2><p>这个文档只是我去学Flutter后遇到的一些问题的理解，以及对Flutter整个框架粗略的概括，并非完整教程，类似于你去看电视剧，你需要一集一集的追下去，然后直到结局才能窥见全貌，而这个文档相当于一种剧透，或者说剧情的概括，看完之后脑海中与一个大体的轮廓，这个Flutter是个什么东西，然后你可以去详细的，认真的跟着教程去学习，丰富轮廓内的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
[toc]
&lt;h2 id=&quot;Flutter是什么&quot;&gt;Flutter是什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Flutter是一个基于&lt;code&gt;Dart&lt;/code&gt;语言的跨平台&lt;strong</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Flutter" scheme="https://lazy.wiki/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>利用汇编挖掘编程语言本质</title>
    <link href="https://lazy.wiki/posts/2102ad03/"/>
    <id>https://lazy.wiki/posts/2102ad03/</id>
    <published>2020-07-05T07:46:39.000Z</published>
    <updated>2022-05-21T08:27:14.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Get">Get</h2><h3 id="1-汇编代码和二进制代码一一对应，">1. 汇编代码和二进制代码一一对应，</h3><ol><li>每一句汇编代码和二进制代码一一对应，所以二进制代码可以反汇编出汇编代码（伪代码，不一定百分之百准确），</li><li>汇编代码根据平台不同会有所不同，x86,armv7,arm64等，由于不同平台会有不同的指令集，所以同样的高级语言编译出来的汇编代码可能会不同，但是大同小异</li></ol><h3 id="2-ifelse和switch的效率">2. ifelse和switch的效率</h3><ol><li>通过汇编可发现，某些情况下，switch效率会比ifelse高（case比较多，且相互之间差值不大，如果差值非常大会用类似ifelse的处理方式），因为ifelse会执行每一个情况的判断代码，不符合则跳转下一个，最终执行完所有的ifelse，</li><li>switch则会通过一定算法，直接算出结果，然后跳转到相应的语句的内存地址</li></ol><h3 id="3-函数的内存分布">3. 函数的内存分布</h3><ol><li>函数的调用会开辟栈空间，栈空间会有指针（esp，平台不同名称可能不同）标识栈顶的位置</li><li>每次压栈都会更新栈顶，函数栈空间会存储局部变量等，每次函数执行完成，esp都会回到调用函数前的位置，这叫做栈平衡，防止栈溢出</li><li>因为每次调用函数都会开辟栈空间，esp都会移动到栈顶，所以递归函数如果没有退出条件，esp会一直移动，直到栈空间不足，栈溢出程序报错</li><li>esp只是标识栈顶的位置，所标记内存地址之下（更小的地址）被视为未使用内存，可以分配给新的函数或变量使用，但其实每次使用后，内存中存储的数据还在，只是被标记为未使用，下次使用可以直接覆盖内容</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Get&quot;&gt;Get&lt;/h2&gt;
&lt;h3 id=&quot;1-汇编代码和二进制代码一一对应，&quot;&gt;1. 汇编代码和二进制代码一一对应，&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;每一句汇编代码和二进制代码一一对应，所以二进制代码可以反汇编出汇编代码（伪代码，不一定百分之百准确），&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="汇编" scheme="https://lazy.wiki/tags/%E6%B1%87%E7%BC%96/"/>
    
    <category term="重学开发" scheme="https://lazy.wiki/tags/%E9%87%8D%E5%AD%A6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《中国合伙人》台词</title>
    <link href="https://lazy.wiki/posts/ae7bbd5b/"/>
    <id>https://lazy.wiki/posts/ae7bbd5b/</id>
    <published>2020-05-02T14:56:07.000Z</published>
    <updated>2022-05-21T08:27:14.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“梦想是什么，梦想就是一种让你感到坚持就是幸福的东西”</strong></p></blockquote><blockquote><p><strong>“我们在这谈了太多的思潮，主义，方法，为什么？因为我们都想找到一个现成的答案，我们都希望有人能够告诉我们应该怎样去生活，其实呢，没有人能告诉我们怎样去生活，因为生活是自己的，我们自己提出的问题应该自己去回答”——孟晓骏语</strong></p></blockquote><p>其实每个人都有自己的人生路要走，无关乎对错，无论最后你活成了什么样，多年后当你能够平淡的和子孙后代说起来时，你的人生，依旧称得上传奇。</p><blockquote><p><strong>“事实证明，一个人迫于无奈下的选择，往往是对的”</strong></p></blockquote><p>所谓的迫于无奈的选择其实早已存在心里，只不过是有其他的选择影响你没有踏出这一步，让你在当时的环境下权衡利弊放弃了而已，而此刻的迫于无奈只是让你认识到，你已经什么都没有没有利弊让你去权衡，也没有退路，必须全力以赴，于是自然而然的选择了曾经抛弃的那个选项。</p><blockquote><p><strong>“实践才是检验真理的唯一标准”——王洋语<br>“所谓的美国梦，就是在梦想面前人人机会均等，全世界只有美国能做到这一点”——孟晓骏语</strong></p></blockquote><p>当老师在课堂上讲美国的种族歧视问题时，孟晓骏反驳说老师是从书上看来的美国，此时的他们脑海中充满了对未来的畅想和对美国的向往，根本不能容忍有人说灯塔国的半点瑕疵，这和如今我们的绝大多数学生公知多么相似，历史总是在不断地重演，老师则回答他们“too young ,too naive”而他们也在未来用卑微实践证明现实和理想的差距</p><blockquote><p><strong>“成功者总是不约而同的配合时代的需要”（被学校开除时——王洋语）</strong></p><p><strong>“最大的骗子其实就是我们自己，因为我们总是想改变别人而不愿改变自己”——王洋语</strong></p><p><strong>“我们改变不了世界，是世界改变了我们”——王洋语</strong></p></blockquote><p>回想起刚入学时，大家意气风发，挥斥方遒，孟晓骏曾问哪一个词可以代表我们这代人，最后得出结论，是改变，改变自己，改变身边每一个人，改变世界，</p><blockquote><p><strong>“你还年轻，你可以走的更远”——（孟晓骏餐厅洗盘子收小费）</strong></p></blockquote><p>你还年轻，你可以成为任何你想成为的人，去做任何你想去做的事，现状已经很糟糕了，难道还会更糟糕吗，中国有个成语叫否极泰来，人会变事也会变，或许后天就是晴天。</p><!--> **“我呢教签证咨询，王洋教美语思维，其实这些都是技术竞争力，那么什么是核心竞争力？我们的核心竞争力是你，没有人比一个失败者去讲梦想更有说服力”**--><blockquote><p><strong>“掉在水里你不会淹死，呆在水里你才会淹死”</strong></p></blockquote><p>学如逆水行舟，不进则退，什么都不做就什么都没有</p><blockquote><p><strong>“我不走了，我留下来，成冬青，我以后跟你混”</strong></p></blockquote><p>对应孟晓骏出国时说的那句话，我不回来了，只有经历过真实的美国，只有让他这样从小就自信心慢慢想要改变世界的人经历失败才能说出这种话，同时，也只有他自己知道说出这句话有多无奈和痛苦，这一刻，他才认清现实，才切身体会到了王洋在ktv说的那句话的含义，“我们改变不了世界，是世界改变了我们”</p><blockquote><p><strong>“你有什么成功的公式吗？”“有吗？至少我不知道”</strong></p></blockquote><p>每个人的成功都是偶然和必然的结合，那么每个人的成功当然也是不可复制的，你的经验在另一个人身上不一定百分之百适用，就像我们购买商品是外包装上总会标上一句，图案仅供参考，我们了解他人经验的目的只有一个，得出自己的成功公式，同样，孟晓骏回国后将当时美国的一些先进的思想，模式拿来给成冬青去看，成冬青也是先质疑，然后尝试，最后将这些本土化</p><blockquote><p><strong>“当你意识到失败只是弯路，你就已经走在了成功的直道上”</strong></p></blockquote><p>成功本就是一次一次的失败，一次一次的复盘最后的奖励，当你认识到意识到问题所在是，你也就踏出了收获成功的第一步</p><blockquote><p><strong>“美国人炸了大使馆，你们就来砸英语学校，外星人炸了地球，你们要去砸航天部吗”</strong></p></blockquote><p>这句话出在南斯拉夫大使馆被炸事件之后，当时激起了国人的爱国主义思潮，但同时也让我们看到了群众的盲目和反智。</p><blockquote><p><strong>“你们和三十年前有什么区别，就知道窝里横，中国人打中国人，懦夫”</strong></p></blockquote><p>当人们的情绪无法得到正常的宣泄，往往会将目标转向和它相关的实物，这时的人们是没有理智可言的，他们急于证明自己的勇气正义，阻碍他们的一切都是他们的敌人</p><blockquote><p><strong>“做买卖的，低头弯腰下跪是基本功夫，小姐心态寡妇待遇，复联追求”</strong></p></blockquote><blockquote><p><strong>“重要的不是成功，而是你不能没有尊严——苏梅语”</strong></p></blockquote><p>看看孟晓骏的经历，看看新梦想的经历，对，人不能没有尊严，所有的关于成功所做的一切，都只是为了让你活得更有尊严。</p><blockquote><p><strong>“如果额头终将刻上皱纹，你只能做到，不让皱纹刻在心上”</strong></p></blockquote><p>或许这句话是对所谓的<code>赤子之心</code> <code>不忘初心</code>最白话的解释了</p><blockquote><p><strong>“成冬青压根就没想去改变世界，但它能做到，不被世界改变，永远的土鳖下去”</strong></p></blockquote><p>这是在前文ktv包间里对王洋那一番话的回答，成冬青从来都没有什么雄心壮志，当他两次高考失利的时候，能有第三次机会，能进入大学校门就已经是对他最大的奖赏，他永远关注当下，当所有人都在畅想未来的时候，需要有人告诉世界如何践踏实地。</p><p>孟晓骏计划了四年的上市计划，包括从加入新梦想后提的几十个商业计划，一直到差点和成冬青决裂，其实只是想挽回自己的尊严，想证明自己的价值，所以他在美国的经历回来后没有向王洋和成冬青说起，一次都没有，成冬青送给孟晓骏300平大房子的时候王洋说他不知道孟晓骏要什么，对，没有人知道一个从小接受良好的教育，从小自信满满要改变世界的人遭遇了重大失败后的内心世界是怎样的，当孟晓骏第三次到美国，并且是他们三人因为教材侵权问题一起到美国的时候，孟晓骏带他们来到自己曾经工作过的餐厅，讲述了自己前两次来美国的经历，这两人才知道他受到了怎样的打击，从一个一无所有心怀壮志的学生，到身价不菲事业有成的成功人士，他的所有身份都没有得到他想要的尊重，在第二次来美国将要离开的时候，他在时代广场看到新浪在纳斯达克上市的巨大版幅消息，或许此时他心里想，原来是这样，原来上市就能被这群美国佬正视，这唤回了他曾经的傲气与自信，他必须要获得应有的尊重。</p><p>最终，成冬青的一番演讲让美国人认识到无数平凡的中国学生的真实状况，并且，为新梦想和孟晓骏，赢得了尊重。</p><p>这是一个改变世界和被世界改变的故事，所以，锋芒外漏的孟晓骏活成了成冬青，永远土鳖的成冬青，活成了孟晓骏，就连罗曼蒂克的诗人王洋也不得不说一句<code>真正的感情是安安静静就会来的一点都不折腾</code>。</p><p>最后，愿我们的心上永远都不会出现皱纹，永远的<code>土鳖</code>下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;“梦想是什么，梦想就是一种让你感到坚持就是幸福的东西”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;“我们在这谈了太多的思潮，主义，方法，为什么？因为我们都想找到一个现成的答</summary>
      
    
    
    
    <category term="随笔" scheme="https://lazy.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="电影台词" scheme="https://lazy.wiki/tags/%E7%94%B5%E5%BD%B1%E5%8F%B0%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>《你是我兄弟》台词摘录</title>
    <link href="https://lazy.wiki/posts/fc63e88/"/>
    <id>https://lazy.wiki/posts/fc63e88/</id>
    <published>2020-04-30T10:35:41.000Z</published>
    <updated>2022-05-21T08:27:14.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第六集">第六集</h3><p>“啥叫生意？生意就是让人生变得不可思议”</p><p>“你别以为商人身上就充满铜臭，你仔细想想，钱就是钱，钱不臭啊，跟钱有啥关系，只要人心不臭，钱就不臭”</p><h3 id="第七集">第七集</h3><p>“卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭，看吧，在那镀金的天空中，飘满了死者弯曲的倒影”</p><p>“冰川纪过去了，为什么到处都是冰凌，好望角发现了，为什么死海里千帆相竞，我来到这个世界上，只带着纸 绳索 和身影”</p><p>“我不想第二次被打败，所以，我就不打 – 一枝花”</p><p>“你现在用百分之百的努力辛勤耕耘，但是你只用百分之一的心情期待收获，免得你失恋了活不下去”</p><p>“让你不断回忆的，一定是你没有得到的，正因为人们要不断地回忆，所以现在要尽最大可能地把它美好了，别等到你该回忆的时候你突然发现自己没什么可以回忆的，那人生就惨点喽”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第六集&quot;&gt;第六集&lt;/h3&gt;
&lt;p&gt;“啥叫生意？生意就是让人生变得不可思议”&lt;/p&gt;
&lt;p&gt;“你别以为商人身上就充满铜臭，你仔细想想，钱就是钱，钱不臭啊，跟钱有啥关系，只要人心不臭，钱就不臭”&lt;/p&gt;
&lt;h3 id=&quot;第七集&quot;&gt;第七集&lt;/h3&gt;
&lt;p&gt;“卑鄙是卑鄙者</summary>
      
    
    
    
    <category term="随笔" scheme="https://lazy.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="电影台词" scheme="https://lazy.wiki/tags/%E7%94%B5%E5%BD%B1%E5%8F%B0%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>OCLint静态代码校验初探</title>
    <link href="https://lazy.wiki/posts/7dc3b748/"/>
    <id>https://lazy.wiki/posts/7dc3b748/</id>
    <published>2019-08-19T13:04:41.000Z</published>
    <updated>2022-05-21T08:27:14.921Z</updated>
    
    <content type="html"><![CDATA[<h1>OCLint静态代码校验初探</h1><p><strong>“OCLint是一个能够让我们的OC，C，C++代码变得更加优雅的检测分析工具–鲁迅”</strong></p><h4 id="OCLint的目的">OCLint的目的</h4><p>   在开发过程中，特别是团队协作开发中，规范的重要性不言而喻，他可以降低沟通成本，增加代码可读性与可维护性提高可靠性与健壮性，作为一名优秀的开发人员，我们应该不断完善并严格遵守相关规范，但是实际情况是，由于我们的疏忽，或者工期的紧张等因素，导致在某些时候开发过程中变得随心所欲，代码变得为所欲为，进而对后期的维护造成不良影响，甚至原地crash&gt;_&lt;!，而<code>OCLint</code>可以帮助我们来检查代码是否遵守了某些规范，是否存在一些潜在的问题，降低review成本。</p><h4 id="OCLint能检测哪些问题">OCLint能检测哪些问题</h4><p>附官方文档<a class="link"   href="http://oclint.org" >OCLint<i class="fas fa-external-link-alt"></i></a></p><ul><li>代码长度，过长或过短，包含方法，变量等</li><li>未使用的代码，包括变量和方法</li><li>代码复杂度，多重循环以及多重判断等</li><li>语法错误</li></ul><h4 id="OCLint安装">OCLint安装</h4><p>   OCLint有多种安装方式，此处采取<code>Homebrew</code>安装，so 默认你的电脑已经安装了<code>Homebrew</code>,如果没安装，请先去安装<a class="link"   href="https://brew.sh/index_zh-cn.html" >Homebrew<i class="fas fa-external-link-alt"></i></a>,一次就够，你会爱上它的😊</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap oclint/formulae</span><br><span class="line">brew install oclint</span><br></pre></td></tr></table></figure><p>  为什么要执行第一句？因为要先安装<code>OCLint</code>的依赖，否则会报错，安装结束执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oclint --version</span><br></pre></td></tr></table></figure><p>  如果出现类似下面的信息，说明安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LLVM (http://llvm.org/):</span><br><span class="line">LLVM version 5.0.0svn-r313528</span><br><span class="line">Optimized build.</span><br><span class="line">Default target: x86_64-apple-darwin18.6.0</span><br><span class="line">Host CPU: skylake</span><br><span class="line"></span><br><span class="line">OCLint (http://oclint.org/):</span><br><span class="line">OCLint version 0.13.</span><br><span class="line">Built Sep 18 2017 (08:58:40).</span><br></pre></td></tr></table></figure><p>  紧接着安装<code>xcpretty</code>这个东西是什么呢？它可以格式化<code>xcodebuild</code>的输出，增加可读性并可以生成报告,执行下面命令安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install xcpretty</span><br></pre></td></tr></table></figure><p>   安装结束检查是否安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcpretty -v</span><br></pre></td></tr></table></figure><p>   如果出现类似下面的版本号信息说明安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.3.0</span><br></pre></td></tr></table></figure><h4 id="OCLint使用">OCLint使用</h4><p>   OCLint作为静态代码检测工具是可以直接在<code>Xcode</code>中使用的，也可以在终端进行操作，本文介绍的是终端操作方式，<code>Xcode</code>使用后续补充；首先进入项目根目录执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild clean </span><br><span class="line">xcodebuild analyze | <span class="built_in">tee</span> xcodebuild.log </span><br></pre></td></tr></table></figure><p>  这一步会对项目进行分析并会在根目录生成一个<code>build</code>目录，并将分析日志输出在<code>xcodebuild.log</code>文件中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild |xcpretty -r json-compilation-database -o compile_commands.json </span><br></pre></td></tr></table></figure><p>  这一步是将编译结果输出在<code>compile_commands.json</code>文件中,这里有一个点要注意的就是，如果你已经编译过并将结果输出在<code>compile_commands.json</code>中，那么再次编译时已编译过的内容是不会被覆盖的，如果希望每次都重头操作，那么可以使用<code>xcodebuild clean</code>命令清除缓存，这也是第一步执行此命令的原因。</p><p>  最后一步是将分析结果生成报告，这中间就会用到各种校验规则了，OCLint默认有些规则，包含了可能出现的大部分场景，当然也可以根据OCLint提供的方法自定义规则,执行如下命令生成报告</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">oclint-json-compilation-database -e Pods -- -report-type html </span><br><span class="line">-rc CYCLOMATIC_COMPLEXITY=5 </span><br><span class="line">-rc TOO_MANY_PARAMETERS=8</span><br><span class="line">-rc NESTED_BLOCK_DEPTH=5</span><br><span class="line">-rc LONG_LINE=200 </span><br><span class="line">-rc NCSS_METHOD=50</span><br><span class="line">-rc LONG_VARIABLE_NAME=30 </span><br><span class="line">-rc SHORT_VARIABLE_NAME=2</span><br><span class="line">-rc LONG_CLASS=1500</span><br><span class="line">-rc LONG_METHOD=150</span><br><span class="line">-disable-rule ShortVariableName </span><br><span class="line">-max-priority-1=10000 </span><br><span class="line">-max-priority-2=10000 </span><br><span class="line">-max-priority-3=10000 &gt; report.html</span><br></pre></td></tr></table></figure><p>  最终会在根目录生成一个<code>report.html</code>文件，点击打开可查看分析结果，大概是下面这个样子<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s1.ax1x.com/2020/03/19/8yHn8U.md.png"                      alt=""                ><br>  另外上述出现的操作命令为了简便写了一个<a class="link"   href="https://github.com/shengguangdaren/OCLint.git" >脚本<i class="fas fa-external-link-alt"></i></a>，仅做参考，需要的自取<br>  因为我此处只是为了展示，所以创建了一个空项目，并没有写内容，所以分析报告一片空白😂😂😂</p><p>  本篇文章只做OCLint使用的初步介绍，实际上我在安装使用的过程中遇到了很多必然或偶然的坑，另外对于<code>OCLint</code>也并没有做详细的介绍，比如<code>OCLint</code>默认规则的介绍，如何自定义规则，相关套件的作用，以及<code>OCLint</code>的缺点等等，随后有时间我会一一整理补充上来。嗯，就酱~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;OCLint静态代码校验初探&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;“OCLint是一个能够让我们的OC，C，C++代码变得更加优雅的检测分析工具–鲁迅”&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;OCLint的目的&quot;&gt;OCLint的目的&lt;/h4&gt;
&lt;p&gt;   在开发过程中，特</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="OCLint" scheme="https://lazy.wiki/tags/OCLint/"/>
    
  </entry>
  
  <entry>
    <title>Pod库创建流程（下）</title>
    <link href="https://lazy.wiki/posts/fcb7297c/"/>
    <id>https://lazy.wiki/posts/fcb7297c/</id>
    <published>2019-07-28T07:41:41.000Z</published>
    <updated>2022-05-21T08:27:14.925Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /> [TOC]<h1>创建pod库流程(下)</h1><p>前边讲了pod库默认工程模板的创建，文件添加存放路径，代码编写位置等基本信息，今天简单说下spec文件的编写及推送。</p><h2 id="第一步">第一步</h2><p>首先我们打开pod库的spec文件,以<code>DYTest</code>项目为例：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8A%E5%8D%8811.55.39.png"                      alt="屏幕快照 2019-07-28 上午11.55.39"                ><br>其中红色箭头所指的就是项目的spec文件，红色方框内就是pod默认的spec文件的内容，里边有很多字段分别对应不同的配置信息，但一般来说我们<strong>只需要</strong>配置其中的几项就可以，其他的可以暂时删掉。</p><p>删完之后大概如下图：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">  s.name             = <span class="string">&#x27;DYTest&#x27;</span></span><br><span class="line">  s.version          = <span class="string">&#x27;0.1.0&#x27;</span></span><br><span class="line">  s.summary          = <span class="string">&#x27;A short description of DYTest.&#x27;</span></span><br><span class="line">  s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">TODO: Add long description of the pod here.</span></span><br><span class="line"><span class="string">                       DESC</span></span><br><span class="line"></span><br><span class="line">  s.homepage         = <span class="string">&#x27;https://github.com/lazyloading@163.com/DYTest&#x27;</span></span><br><span class="line">  s.license          = &#123; <span class="symbol">:type</span> =&gt; <span class="string">&#x27;MIT&#x27;</span>, <span class="symbol">:file</span> =&gt; <span class="string">&#x27;LICENSE&#x27;</span> &#125;</span><br><span class="line">  s.author           = &#123; <span class="string">&#x27;lazyloading@163.com&#x27;</span> =&gt; <span class="string">&#x27;lazyloading@163.com&#x27;</span> &#125;</span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/lazyloading@163.com/DYTest.git&#x27;</span>, <span class="symbol">:tag</span> =&gt; s.version.to_s &#125;</span><br><span class="line">  s.ios.deployment_target = <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">  s.source_files = <span class="string">&#x27;DYTest/Classes/**/*&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中</p><ul><li><p><a class="link"   href="http://s.name" >s.name<i class="fas fa-external-link-alt"></i></a> : 你所创建的库的名字，比如Masonry，AFNNetworking等等</p></li><li><p>s.version ： 库的版本号</p></li><li><p>s.summary ： 简短的描述信息</p></li><li><p>s.description ： 比简短描述长一点的描述信息</p></li><li><p>s.homepage ： pod库远程仓库主页地址 我们此次的示例工程的主页就是 <code>http://git.zhcs.com/iOS_Group/DYTest</code></p></li><li><p>s.license ： 遵守的协议</p></li><li><p>s.author ： 创建人</p></li><li><p>s.ios.deployment_target ： 支持的系统版本版本此次示例工程支持到<code>iOS 8.0</code></p></li><li><p>s.source ： 你的pod库的远程仓库路径，我们此次的示例工程的路径就是<code>http://192.168.120.30/iOS_Group/DYTest.git</code></p></li><li><p>s.source_files = 要加入库中的代码在工程中的路径，此次示例工程编写的代码就在之前强调的<code>'DYTest/Classes/**/*'</code>路径下</p></li></ul><h2 id="第二步">第二步</h2><p>当库每个版本代码编写完成后我们需要将pod库代码提交到对应的远程仓库，同时对应的spec文件也要推送到spec文件远程仓库。</p><p>第一步我们完成了spec文件的编写，第二步我们就要推送spec文件，此次示例工程我们的spec文件远程仓库就是我们前文所创建的<code>http://192.168.120.30/iOS_Group/DYTestSpecs.git</code></p><p>我们先对spec文件做一个本地校验看看是否有配置错误：</p><p>进入spec文件所在目录<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8B%E5%8D%882.34.53.png"                      alt="屏幕快照 2019-07-28 下午2.34.53"                ></p><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint </span><br></pre></td></tr></table></figure><p>当你在spec文件所在目录并且只有一个spec文件时候你可以这么写，否则你需要指定你要校验的spec文件用如下写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint DYTest.podspec</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8B%E5%8D%882.39.19.png"                      alt="屏幕快照 2019-07-28 下午2.39.19"                ></p><p>第一次执行<code>pod lib lint </code>未成功，报出了⚠️其实这些警告可以忽略，我们只需要加上<code>--allow-warnings</code>参数，可以看到我们第二次执行成功了，如果你想看校验过程还可以在后边添加<code>--verbose</code>参数</p><p>但是只是做本地校验还不够，毕竟我们的库并不是自己玩玩，是需要让其他人也用的，这就需要推送的远端，远端推送之前就需要进行远端校验，不仅查看语法是否正确，也查看你在远端的代码版本和spec文件中的是否匹配。</p><p>我们先给代码打个<code>tag</code>,然后把tag推送到远程，tag版本需要和spec文件中的<code>s.version</code>一致，此处前边我们spec文件中<code>s.version</code>写的是<code>0.1.0</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8B%E5%8D%882.51.27.png"                      alt="屏幕快照 2019-07-28 下午2.51.27"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8B%E5%8D%882.51.40.png"                      alt="屏幕快照 2019-07-28 下午2.51.40"                ></p><p>至此tag已经打完并推送成功，接下来就是对spec文件进行远程校验<br>操作和本地校验类似只不过命令不同，执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --allow-warnings</span><br></pre></td></tr></table></figure><p>结果如下<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8B%E5%8D%882.56.27.png"                      alt="屏幕快照 2019-07-28 下午2.56.27"                ></p><p>或者我们很自信spec文件绝对没问题，这时候也可以不校验直接推</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push DYTestSpecs *.podspec --sources=http://192.168.120.30/iOS_Group/DYTestSpecs.git,https://github.com/CocoaPods/Specs.git --use-libraries --allow-warnings --verbose</span><br></pre></td></tr></table></figure><p>结果如下:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8B%E5%8D%883.03.05.png"                      alt="屏幕快照 2019-07-28 下午3.03.05"                ></p><p>一次成功，完美，这里忍不住给自己鼓掌，整个操作行云流水一气呵成如德芙版丝滑中途没出现一点意外和错误，嘴角不自觉扬起了迷人的弧度<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/2334192-98329dbf4ae5a5bd.jpg"                      alt="2334192-98329dbf4ae5a5bd"                ></p><p>不过这句命令很长有必要给大家解释下每一部分的含义不然你只会<code>知其然不知其所以然</code>，看看看看，出口成章，小伙子学着点以后要多读书啊。<br>其中<code>DYTestSpecs</code>是我们第一篇里讲的，添加进本地repo目录下的示例工程对应的spec工程。</p><p><code>*.podspec</code>中*指通配符，这么写指以<code>.podspec</code>为后缀的文件,你也可以指定对应的spec文件，比如我们的示例工程就可以写成 <code>DYTest.podspec</code>。</p><p><code>--sources</code>指的是要将本地repo目录下<code>DYTestSpecs</code>工程推送的远端路径，如果你只想公司内部使用就可以不写后边的<code>https://github.com/CocoaPods/Specs.git</code></p><h2 id="第三步">第三步</h2><p>创建，编写，校验，推送都完成了，接下来就是使用了，我们先<code>search</code>试一下看能不能搜到我们的库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod search DYTest</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15642856190114/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-28%20%E4%B8%8B%E5%8D%883.27.17.png"                      alt="屏幕快照 2019-07-28 下午3.27.17"                ></p><p>嗯，放心了，搜索的到，那么，接下来，就不用我多说了吧，开始愉快的使用吧~</p><p>**后记：**这两篇文章主要说的是私有pod库的创建，编写及推送流程，实际具体使用过程中可能还会遇到其他问题导致你用的头大，比如操作顺序出错导致配置了不可逆的错误环境，操作的天时不对，坐的位置风水不好等等，总之就是很多不可控，玄学问题，这个在这篇文章就不一一细说，后边有问题可以直接问，或者有时间转门写一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
 [TOC]
&lt;h1&gt;创建pod库流程(下)&lt;/h1&gt;
&lt;p&gt;前边讲了pod库默认工程模板的创建，文件添加存放路径，代码编写位置等基本信息，今天简单说下spec文件的编写及推送。&lt;/p&gt;</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Cocoapods" scheme="https://lazy.wiki/tags/Cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>Pod库创建流程（上）</title>
    <link href="https://lazy.wiki/posts/440b4e19/"/>
    <id>https://lazy.wiki/posts/440b4e19/</id>
    <published>2019-07-25T02:38:41.000Z</published>
    <updated>2022-05-21T08:27:14.924Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[toc]</p><h1>创建pod库流程(上)</h1><h2 id="第一步">第一步</h2><p>创建本地私有库，<code>pod lib create 为创建pod模板工程命令``DYTest</code>为私有库名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create DYTest</span><br></pre></td></tr></table></figure><p>结果如下图所示,命令默认会在当前所在目录下创建，图中所示路径为桌面<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%888.59.05.png"                      alt=""                ></p><h2 id="第二步">第二步</h2><p>创建远程仓库，进入刚才创建的DYTest工程根目录将本地创建的私有库工程与远程仓库关联起来，具体操作如下所示：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%889.06.37.png"                      alt=""                ></p><h2 id="第三步">第三步</h2><p>创建远程Spec文件仓库并添加到到本地repo目录，repo目录在本地cocoapods安装目录下，Spec文件为pod工程描述文件，里边可编辑pod库的所有配置信息，名称，地址，支持平台，版本，依赖库等等.<br><code>pod repo add</code>为本地pod添加spec文件命令<code>DYTestSpecs</code>为要添加的spec目录的名称<code>http://192.168.120.30/iOS_Group/DYTestSpecs.git</code>为远程Spec文件仓库地址。</p><p><strong>注意：一个Spec文件仓库可以存放多个pod库的Spec文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add DYTestSpecs http://192.168.120.30/iOS_Group/DYTestSpecs.git</span><br></pre></td></tr></table></figure><p>结果如下:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%889.20.08.png"                      alt=""                ></p><h2 id="第四步">第四步</h2><p>至此我们便可以着手在pod库里进行代码编写工作，由此流程创建的pod库文件根目录结构大概如下图所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%889.23.20.png"                      alt="屏幕快照 2019-07-25 上午9.23.20"                ></p><p>其中<code>Example</code>文件夹为pod模板自带的示例工程，我们在pod库中编写的代码可通过此示例工程进行调试，<code>DYTest</code>文件夹为我们将要编写代码的物理路径，目录结构如下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%889.26.20.png"                      alt="屏幕快照 2019-07-25 上午9.26.20"                ></p><p><code>Classes</code>文件夹即我们编写的pod库代码所在的文件物理路径</p><p>下面我们打开项目看一下：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/WeChat865ff9360b497c1dd165b1d7d9f4f6d8.png"                      alt="WeChat865ff9360b497c1dd165b1d7d9f4f6d8"                ></p><p>其中<strong>创建时路径不要选错，是在<code>Classes</code>文件夹下</strong>箭头所指的文件为我们当前pod库的spec文件，将来如果要发布被他人搜索使用就需要编写此spec文件对应信息并将其推送单刚才创建的远程spec仓库<code>DYTestSpecs</code>中。</p><p><strong>绿色</strong>箭头所指为我们的<code>Example</code>示例工程目录。</p><p><strong>红色</strong>箭头所指为我们pod库工程代码目录，<strong>此目录为虚拟文件夹，其下文件物理路径为前文所述的<code>Classes</code>文件夹,一定要注意创建文件时候不要选错存放路径，应该存放在<code>Classes</code>下</strong>。</p><p>每当我们添加新的文件时需要进入<code>Example</code>目录下进行<code>update</code>操作，这样创建的文件会自动加入工程，不进行<code>update</code>操作你的文件在使用时将会提示<code>not found</code>,具体操作如下所示:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%889.40.28.png"                      alt="屏幕快照 2019-07-25 上午9.40.28"                ></p><p><strong>创建时路径不要选错，是在<code>Classes</code>文件夹下</strong></p><p>下面进行<strong>update</strong>操作<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%8810.24.00.png"                      alt="屏幕快照 2019-07-25 上午10.24.00"                ><br>注意路径，是在<code>Example</code>目录下进行update,完成后我们新创建的文件就可以<code>import</code>使用了</p><p>当一天的工作完成后需要进行代码提交，那么我们进入项目根目录进行代码提交，<br><img                       lazyload                     src="/images/loading.svg"                     data-src="media/15640160877905/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-25%20%E4%B8%8A%E5%8D%8810.32.10.png"                      alt="屏幕快照 2019-07-25 上午10.32.10"                ></p><p>分支根据情况自行选择，此处我选择master，pod库创建的简单流程及代码编写大体就这样，下次详细说一下spec文件的编写以及pod库某一阶段完成后打tag，进行推送以供他人<code>search``install</code>的流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1&gt;创建pod库流程(上)&lt;/h1&gt;
&lt;h2 id=&quot;第一步&quot;&gt;第一步&lt;/h2&gt;
&lt;p&gt;创建本地私有库，&lt;code&gt;pod lib create 为创建po</summary>
      
    
    
    
    <category term="开发" scheme="https://lazy.wiki/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Cocoapods" scheme="https://lazy.wiki/tags/Cocoapods/"/>
    
  </entry>
  
</feed>
